# netaio

## Classes

### `TCPClient`

TCP client class with multi-server connection support. A single TCPClient can
connect to multiple servers simultaneously. Each server connection has its own
receive loop that can be started and stopped independently. Use `connect()` to
establish connections, `start_receive_loop()` to begin receiving from a server,
and `close()` to disconnect.

#### Annotations

- hosts: dict[tuple[str, int], tuple[asyncio.StreamReader,
asyncio.StreamWriter]]
- default_host: tuple[str, int]
- port: int
- local_peer: Peer | None
- peers: dict[bytes, Peer]
- peer_addrs: dict[tuple[str, int], bytes]
- header_class: type[HeaderProtocol]
- message_type_class: type[IntEnum]
- auth_fields_class: type[AuthFieldsProtocol]
- body_class: type[BodyProtocol]
- message_class: type[MessageProtocol]
- handlers: dict[Hashable, tuple[AnyHandler, AuthPluginProtocol | None,
CipherPluginProtocol | None]]
- ephemeral_handlers: dict[Hashable, tuple[AnyHandler, AuthPluginProtocol |
None, CipherPluginProtocol | None]]
- default_handler: AnyHandler
- extract_keys: Callable[[MessageProtocol, tuple[str, int] | None],
list[Hashable]]
- make_error: Callable[[str], MessageProtocol]
- logger: logging.Logger
- auth_plugin: AuthPluginProtocol | None
- cipher_plugin: CipherPluginProtocol | None
- peer_plugin: PeerPluginProtocol | None
- handle_auth_error: AuthErrorHandler
- timeout_error_handler: TimeoutErrorHandler | None
- _receive_loop_tasks: dict[tuple[str, int], asyncio.Task]
- _receive_loop_lock: asyncio.Lock
- _timeout_handler_tasks: set[asyncio.Task]
- _timeout_handler_lock: asyncio.Lock
- _advertise_msg: MessageProtocol | None
- _disconnect_msg: MessageProtocol | None

#### Methods

##### `__init__(host: str = '127.0.0.1', port: int = 8888, /, *, timeout_error_handler: TimeoutErrorHandler | None = None, auth_error_handler: AuthErrorHandler = <function auth_error_handler at 0x78a5047e3920>, peer_plugin: PeerPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, logger: logging.Logger = <Logger netaio.client (INFO)>, extract_keys: Callable[[MessageProtocol, tuple[str, int] | None], list[Hashable]] = <function keys_extractor at 0x78a5050e5e40>, message_class: type[MessageProtocol] = Message, body_class: type[BodyProtocol] = Body, auth_fields_class: type[AuthFieldsProtocol] = AuthFields, message_type_class: type[IntEnum] = <enum 'MessageType'>, header_class: type[HeaderProtocol] = Header, local_peer: Peer | None = None):`

Initialize the TCPClient. `host` is the default host IPv4 address to connect to.
`port` is the default port to connect to. `local_peer` is the local peer
information for this client. `header_class`, `auth_fields_class`, `body_class`,
and `message_class` will be used for sending messages and parsing responses.
`message_type_class` is the class to inject in calls to the decode method of the
header class. `extract_keys` is a function that extracts the keys from a
message. If `auth_plugin` is provided, it will be used to check the
authenticity/authorization of all received messages and set the `auth_fields` of
every sent message. If `cipher_plugin` is provided, it will be used to encrypt
and decrypt all messages. If `peer_plugin` is provided, it will be used to
encode and decode peer data. `auth_error_handler` is a function that handles
auth errors, i.e. when an auth check fails for a received message. If it returns
a message, that message will be sent as a response to the sender of the message
that failed the auth check. The default handler returns the error message
generated by the auth plugin and should be replaced if you do not want to send
error messages for failed auth checks (e.g. if the auth plugin is an anti-spam
plugin and messages that fail the auth check should just be dropped).
`timeout_error_handler` is a function that handles timeout errors. It is called
with (`self`, `timeout_type`, `server`, `error`, `context`) and can perform
recovery actions like reconnecting or logging. The `TimeoutError` is always
raised after the handler completes.

##### `add_handler(key: Hashable, handler: AnyHandler, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return `MessageProtocol`, `None`, or
a `Coroutine` that resolves to `MessageProtocol | None`. If an auth plugin is
provided, it will be used to check the message in addition to any auth plugin
that is set on the client. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the client.

##### `add_ephemeral_handler(key: Hashable, handler: AnyHandler, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Register an ephemeral handler for a specific key. The handler will be removed
either after it is called the first time. Otherwise identical to `add_handler`.

##### `on(key: Hashable, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Decorator to register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return a `MessageProtocol`, `None`,
or a `Coroutine` that resolves to a `MessageProtocol | None`. If an auth plugin
is provided, it will be used to check the message in addition to any auth plugin
that is set on the client. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the client.

##### `once(key: Hashable, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Decorator to register a one-time handler for a specific key. The handler must
accept a `MessageProtocol` object as an argument and return a `MessageProtocol`,
`None`, or a `Coroutine` that resolves to a `MessageProtocol | None`. If an auth
plugin is provided, it will be used to check the message in addition to any auth
plugin that is set on the client. If a cipher plugin is provided, it will be
used to decrypt the message in addition to any cipher plugin that is set on the
client.

##### `remove_handler(key: Hashable):`

Remove a handler for a specific key.

##### `remove_ephemeral_handler(key: Hashable):`

Remove an ephemeral handler for a specific key.

##### `async connect(host: str | None = None, port: int | None = None):`

Connect to a server. The connection is stored in the hosts dict. To receive
messages from this server, start a receive loop via `start_receive_loop()`.
Multiple servers can be connected to simultaneously.

##### `async send(message: MessageProtocol, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, server: tuple[str, int] | None = None):`

Send a message to the server. If `use_auth` is `True` and an auth plugin is set,
it will be called to set the auth fields on the message. If an auth plugin is
provided, it will be used to authorize the message in addition to any auth
plugin that is set on the client. If a cipher plugin is provided, it will be
used to encrypt the message in addition to any cipher plugin that is set on the
client. If `use_auth` is `False`, the auth plugin set on the client will not be
used. If `use_cipher` is `False`, the cipher plugin set on the client will not
be used.

##### `async request(uri: bytes, /, *, content: bytes = b'', message_type: int | None = None, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, timeout: float = 10.0, server: tuple[str, int] | None = None) -> MessageProtocol:`

Send a request message and wait for a response. Sets ephemeral handlers for
`OK`, `RESPOND_URI`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types, then
sends a message to the connected server. Waits until a response (success or
error) is received or timeout is reached. If it times out, removes all ephemeral
handlers and raises a `TimeoutError`. If a response is received, returns that
message (caller should check `message.header.message_type` to determine success
or error). When `message_type` is `None` (default), sends `REQUEST_URI`. Use
`message_type` and content to send `CREATE_URI`, `UPDATE_URI`, or `DELETE_URI`
messages.

##### `async create(uri: bytes, data: bytes, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, timeout: float = 10.0, server: tuple[str, int] | None = None) -> MessageProtocol:`

Send a `CREATE_URI` message and wait for an OK response. Sets ephemeral handlers
for `OK`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types using
`add_ephemeral_handler`, then sends a `CREATE_URI` message to the connected
server. Waits until either a response (success or error) is received or timeout
is reached. If it times out, removes all ephemeral handlers and raises a
`TimeoutError`. If a response is received, returns that message (caller should
check `message.header.message_type` to determine if it's a success or error
response).

##### `async update(uri: bytes, data: bytes, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, server: tuple[str, int] | None = None, timeout: float = 10.0) -> MessageProtocol:`

Send an `UPDATE_URI` message and wait for an `OK` response. Sets ephemeral
handlers for `OK`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types using
`add_ephemeral_handler`, then sends an `UPDATE_URI` message to the connected
server. Waits until either a response (success or error) is received or timeout
is reached. If it times out, removes all ephemeral handlers and raises a
`TimeoutError`. If a response is received, returns that message (caller should
check `message.header.message_type` to determine if it's a success or error
response).

##### `async delete(uri: bytes, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, server: tuple[str, int] | None = None, timeout: float = 10.0) -> MessageProtocol:`

Send a `DELETE_URI` message and wait for an `OK` response. Sets ephemeral
handlers for `OK`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types using
`add_ephemeral_handler`, then sends a `DELETE_URI` message to the connected
server. Waits until either a response (success or error) is received or timeout
is reached. If it times out, removes all ephemeral handlers and raises a
`TimeoutError`. If a response is received, returns that message (caller should
check `message.header.message_type` to determine if it's a success or error
response).

##### `async receive_once(server: tuple[str, int] | None = None, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True) -> MessageProtocol | None:`

Receive a message from the server. If a handler was registered for the message
key, the handler will be called with the message as an argument, and the result
will be returned if it is not `None`; otherwise, the received message will be
returned. If the message checksum fails, the message will be discarded and
`None` will be returned. If an auth plugin is set, it will be checked before the
message handler is called, and if the check fails, the message will be discarded
and `None` will be returned. If `use_auth` is `False`, the auth plugin set on
the client will not be used. If `use_cipher` is `False`, the cipher plugin set
on the client will not be used. If an auth plugin is provided, it will be used
to check the message in addition to any auth plugin that is set on the client.
If a cipher plugin is provided, it will be used to decrypt the message in
addition to any cipher plugin that is set on the client.

##### `async receive_loop(server: tuple[str, int] | None = None, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Receive messages from the server indefinitely. Use with `asyncio.create_task()`
to run concurrently, then use `task.cancel()` to stop. If use_auth is False, the
auth plugin set on the client will not be used. If `use_cipher` is `False`, the
cipher plugin set on the client will not be used. If an auth plugin is provided,
it will be used to check the message in addition to any auth plugin that is set
on the client. If a cipher plugin is provided, it will be used to decrypt the
message in addition to any cipher plugin that is set on the client. Note: This
method is typically called via `start_receive_loop()` for better lifecycle
management.

##### `async start_receive_loop(server: tuple[str, int] | None = None, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True) -> tuple[asyncio.Task, bool]:`

Start a receive loop for a specific server which will continue receiving
messages from specified server indefinitely until stopped. If a receive loop is
already running for this server, returns the existing task. Also returns a
`was_running` bool which is `True` if a task was already running and `False` if
one was started.

##### `async stop_receive_loop(server: tuple[str, int] | None = None) -> bool:`

Stop the receive loop for a specific server by cancelling and waiting for the
task to complete. Returns `True` if a receive loop was stopped, `False` if no
receive loop was running for this server.

##### `async stop_all_receive_loops() -> int:`

Stop all running receive loops. Returns number of receive loops that were
stopped.

##### `async get_receive_loops() -> dict[tuple[str, int], asyncio.Task]:`

Get a copy of all active receive loop tasks. Returns a dictionary mapping server
addresses to their receive loop tasks.

##### `async close(server: tuple[str, int] | None = None):`

Close the connection to the server. Cancels any running receive loop for the
server and closes the connection. Pass a `server` argument to disconnect from a
non-default server.

##### `add_or_update_peer(peer_id: bytes, peer_data: bytes, addr: tuple[str, int]) -> bool:`

Add or update a peer in the peer list. If the peer is the local peer, it will
not be added to the peer list. Returns `True` if a `PEER_DISCOVERED` message
should be sent (`False` if it is the local peer).

##### `get_peer(addr: tuple[str, int] | None = None, peer_id: bytes | None = None) -> Peer | None:`

Get a peer from the peer list if `addr` or `peer_id` is provided and if it
exists. Prefers `peer_id` if both are provided but will fall back to `addr` if
the provided `peer_id` is not found.

##### `remove_peer(addr: tuple[str, int], peer_id: bytes):`

Remove a peer from the peer list.

##### `async manage_peers_automatically(app_id: bytes = b'netaio', /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Begins automatic peer management: when the client connects to a server, it will
send its local_peer data. This also registers 3 handlers: 1) for the
`ADVERTISE_PEER` message, which will add the peer to the peer list and send a
`PEER_DISCOVERED` message to reciprocate; 2) for the `PEER_DISCOVERED` message
type which will add the peer to the peer list; and 3) for the `DISCONNECT`
message which will remove the peer from the local peer list. Then, it will send
an `ADVERTISE_PEER` message to each server it has already connected to. Raises
`AssertionError` if `local_peer` is not set or if the message_type_class does
not contain `ADVERTISE_PEER`, `PEER_DISCOVERED`, and `DISCONNECT` message types.

##### `async stop_peer_management(app_id: bytes = b'netaio'):`

Stops automatic peer management by disabling the feature, sending a `DISCONNECT`
message, and removing the handlers.

##### `set_logger(logger: logging.Logger):`

Replace the current logger.

##### `set_timeout_handler(handler: TimeoutErrorHandler):`

Set or replace the timeout error handler. Experimental and of unknown utility as
of v0.0.9.

##### `async cancel_timeout_handler_tasks():`

Cancel all running timeout handler tasks.

### `AutoReconnectTimeoutHandler`

Bundled timeout handler that automatically reconnects to server. Runs as a side
effect when a timeout occurs, attempting to re-establish the connection so
subsequent requests can succeed. The original TimeoutError is always raised
after the handler completes.

#### Methods

##### `__init__(connect_timeout: float = 5.0, max_retries: int = 3, delay: float = 1.0, on_reconnect: Callable[[TCPClient, tuple[str, int], int], Awaitable[None] | None] | None = None):`

### `TCPServer`

TCP server class.

#### Annotations

- port: <class 'int'>
- interface: <class 'str'>
- local_peer: netaio.common.Peer | None
- peers: dict[bytes, netaio.common.Peer]
- peer_addrs: dict[tuple[str, int], bytes]
- handlers: dict[typing.Hashable,
tuple[typing.Union[typing.Callable[[netaio.common.MessageProtocol,
asyncio.streams.StreamWriter], typing.Union[netaio.common.MessageProtocol,
NoneType, typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol
| None]]], typing.Callable[[netaio.common.MessageProtocol, tuple[str, int]],
typing.Union[netaio.common.MessageProtocol, NoneType,
typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol |
None]]]], netaio.common.AuthPluginProtocol | None,
netaio.common.CipherPluginProtocol | None]]
- ephemeral_handlers: dict[typing.Hashable,
tuple[typing.Union[typing.Callable[[netaio.common.MessageProtocol,
asyncio.streams.StreamWriter], typing.Union[netaio.common.MessageProtocol,
NoneType, typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol
| None]]], typing.Callable[[netaio.common.MessageProtocol, tuple[str, int]],
typing.Union[netaio.common.MessageProtocol, NoneType,
typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol |
None]]]], netaio.common.AuthPluginProtocol | None,
netaio.common.CipherPluginProtocol | None]]
- default_handler: typing.Union[typing.Callable[[netaio.common.MessageProtocol,
asyncio.streams.StreamWriter], typing.Union[netaio.common.MessageProtocol,
NoneType, typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol
| None]]], typing.Callable[[netaio.common.MessageProtocol, tuple[str, int]],
typing.Union[netaio.common.MessageProtocol, NoneType,
typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol |
None]]]]
- header_class: type[netaio.common.HeaderProtocol]
- message_type_class: type[enum.IntEnum]
- auth_fields_class: type[netaio.common.AuthFieldsProtocol]
- body_class: type[netaio.common.BodyProtocol]
- message_class: type[netaio.common.MessageProtocol]
- extract_keys: typing.Callable[[netaio.common.MessageProtocol, tuple[str, int]
| None], list[typing.Hashable]]
- make_error: typing.Callable[[str], netaio.common.MessageProtocol]
- subscriptions: dict[typing.Hashable, set[asyncio.streams.StreamWriter]]
- clients: set[asyncio.streams.StreamWriter]
- logger: <class 'logging.Logger'>
- auth_plugin: netaio.common.AuthPluginProtocol | None
- cipher_plugin: netaio.common.CipherPluginProtocol | None
- peer_plugin: netaio.common.PeerPluginProtocol | None
- handle_auth_error: typing.Callable[[netaio.common.NetworkNodeProtocol,
netaio.common.AuthPluginProtocol, netaio.common.MessageProtocol | None],
netaio.common.MessageProtocol | None]

#### Methods

##### `__init__(port: int = 8888, interface: str = '0.0.0.0', /, *, auth_error_handler: Callable = <function auth_error_handler at 0x78a5047e3920>, peer_plugin: netaio.common.PeerPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None, logger: Logger = <Logger netaio.server (INFO)>, default_handler: Union = <function not_found_handler at 0x78a5047f8d60>, make_error_msg: Callable = <function make_error_msg at 0x78a5047e3740>, keys_extractor: Callable = <function keys_extractor at 0x78a5050e5e40>, message_class: type[netaio.common.MessageProtocol] | None = None, body_class: type = Body, auth_fields_class: type = AuthFields, message_type_class: type = <enum 'MessageType'>, header_class: type[netaio.common.HeaderProtocol] | None = None, local_peer: netaio.common.Peer | None = None):`

Initialize the TCPServer. `interface` is the interface to listen on. `port` is
the port to listen on. `local_peer` is the local peer information for this
server. `header_class`, `auth_fields_class`, `body_class`, and `message_class`
will be used for sending messages and parsing responses. `message_type_class` is
the class to inject in calls to the decode method of the header class.
`keys_extractor` is a function that extracts the keys from a message.
`make_error_msg` is a function that makes an error message. `default_handler` is
the default handler to use for messages that do not match any registered handler
keys. If `auth_plugin` is provided, it will be used to check the
authenticity/authorization of all received messages and set the `auth_fields` of
every sent message. If `cipher_plugin` is provided, it will be used to encrypt
and decrypt all messages. If `peer_plugin` is provided, it will be used to
encode and decode peer data. `auth_error_handler` is a function that handles
auth errors, i.e. when an auth check fails for a received message. If it returns
a message, that message will be sent as a response to the sender of the message
that failed the auth check. The default handler returns the error message
generated by the auth plugin and should be replaced if you do not want to send
error messages for failed auth checks (e.g. if the auth plugin is an anti-spam
plugin and messages that fail the auth check should just be dropped).

##### `add_handler(key: Hashable, handler: Union, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None):`

Register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return a `MessageProtocol`, `None`,
or a `Coroutine` that resolves to `MessageProtocol | None`. If an auth plugin is
provided, it will be used to check the message in addition to any auth plugin
that is set on the server. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the server.
These plugins will also be used for preparing any response message sent by the
handler.

##### `add_ephemeral_handler(key: Hashable, handler: Union, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None):`

Register an ephemeral handler for a specific key. The handler will be removed
either after it is called the first time. Otherwise identical to `add_handler`.

##### `on(key: Hashable, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None):`

Decorator to register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return a `MessageProtocol`, `None`,
or a `Coroutine` that resolves to a `MessageProtocol | None`. If an auth plugin
is provided, it will be used to check the message in addition to any auth plugin
that is set on the server. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the server.
These plugins will also be used for preparing any response message sent by the
handler.

##### `once(key: Hashable, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None):`

Decorator to register a one-time handler for a specific key. The handler must
accept a `MessageProtocol` object as an argument and return a `MessageProtocol`,
`None`, or a `Coroutine` that resolves to a `MessageProtocol | None`. If an auth
plugin is provided, it will be used to check the message in addition to any auth
plugin that is set on the server. If a cipher plugin is provided, it will be
used to decrypt the message in addition to any cipher plugin that is set on the
server. These plugins will also be used for preparing any response message sent
by the handler.

##### `remove_handler(key: Hashable):`

Remove a handler for a specific key.

##### `remove_ephemeral_handler(key: Hashable):`

Remove an ephemeral handler for a specific key.

##### `subscribe(key: Hashable, writer: StreamWriter):`

Subscribe a client to a specific key. The key must be a Hashable object.

##### `unsubscribe(key: Hashable, writer: StreamWriter):`

Unsubscribe a client from a specific key. If no subscribers are left, the key
will be removed from the subscriptions dictionary.

##### `async handle_client(reader: StreamReader, writer: StreamWriter, /, *, use_cipher: bool = True, use_auth: bool = True):`

Handle a client connection. When a client connects, it is added to the clients
set. The client is then read from using the receive method coroutine until the
connection is lost. The receive method calls the proper handlers if they are
defined and the message is valid. If `use_auth` is `False`, the auth plugin set
on the server will not be used. If `use_cipher` is `False`, the cipher plugin
set on the server will not be used.

##### `async receive(reader: StreamReader, writer: StreamWriter, /, *, use_cipher: bool = True, use_auth: bool = True):`

Receive and process a message from a client. Used by the `handle_client`
coroutine. Calls the proper handlers if they are defined and the message is
valid. If `use_auth` is `False`, the auth plugin set on the server will not be
used. If `use_cipher` is `False`, the cipher plugin set on the server will not
be used.

##### `async start(/, *, use_cipher: bool = True, use_auth: bool = True):`

Start the server.

##### `async stop():`

Stops the server.

##### `prepare_message(message: MessageProtocol, /, *, peer: netaio.common.Peer | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True) -> netaio.common.MessageProtocol | None:`

Prepares a message for transmission by invoking all necessary plugins.

##### `async send(client: StreamWriter, message: MessageProtocol, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, collection: set[asyncio.streams.StreamWriter] | None = None):`

Helper coroutine to send a message to a client. On error, it logs the exception
and removes the client from the given collection. If an auth plugin is provided,
it will be used to authorize the message in addition to any auth plugin that is
set on the server. If a cipher plugin is provided, it will be used to encrypt
the message in addition to any cipher plugin that is set on the server. If
`use_auth` is `False`, the auth plugin set on the server will not be used. If
`use_cipher` is `False`, the cipher plugin set on the server will not be used.

##### `async broadcast(message: MessageProtocol, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Send the message to all connected clients concurrently using `asyncio.gather`.
If an auth plugin is provided, it will be used to authorize the message in
addition to any auth plugin that is set on the server. If a cipher plugin is
provided, it will be used to encrypt the message in addition to any cipher
plugin that is set on the server. If `use_auth` is `False`, the auth plugin set
on the server will not be used. If `use_cipher` is `False`, the cipher plugin
set on the server will not be used.

##### `async notify(key: Hashable, message: MessageProtocol, /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Send the message to all subscribed clients for the given key concurrently using
`asyncio.gather`. If an auth plugin is provided, it will be used to authorize
the message in addition to any auth plugin that is set on the server. If a
cipher plugin is provided, it will be used to encrypt the message in addition to
any cipher plugin that is set on the server. If `use_auth` is `False`, the auth
plugin set on the server will not be used. If `use_cipher` is `False`, the
cipher plugin set on the server will not be used.

##### `add_or_update_peer(peer_id: bytes, peer_data: bytes, addr: tuple) -> bool:`

Add or update a peer in the peer list. If the peer is the local peer, it will
not be added to the peer list. Returns `True` if a `PEER_DISCOVERED` message
should be sent (`False` if it is the local peer).

##### `get_peer(addr: tuple[str, int] | None = None, peer_id: bytes | None = None) -> netaio.common.Peer | None:`

Get a peer from the peer list if `addr` or `peer_id` is provided and if it
exists. Prefers `peer_id` if both are provided but will fall back to `addr` if
the provided `peer_id` is not found.

##### `remove_peer(writer: StreamWriter, peer_id: bytes):`

Remove a peer from the peer list and all related subscriptions.

##### `async manage_peers_automatically(app_id: bytes = b'netaio', /, *, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, auth_plugin: netaio.common.AuthPluginProtocol | None = None):`

Begins automatic peer management. This registers 3 handlers: 1) for the
`ADVERTISE_PEER` message, which will add the peer to the peer list and send a
`PEER_DISCOVERED` message to reciprocate; 2) for the `PEER_DISCOVERED` message
type which will add the peer to the peer list; and 3) for the `DISCONNECT`
message which will remove the peer from the local peer list. Then, it will send
an `ADVERTISE_PEER` message to each client that has already connected to it. For
new connections, the client is expected to introduce itself before the server
responds with its peer data; it will not send an `ADVERTISE_PEER` message to
newly connected clients. Raises `AssertionError` if `local_peer` is not set or
if the `message_type_class` does not contain `ADVERTISE_PEER`,
`PEER_DISCOVERED`, and `DISCONNECT` message types.

##### `async stop_peer_management(app_id: bytes = b'netaio'):`

Stops automatic peer management by removing the handlers.

##### `set_logger(logger: Logger):`

Replace the current logger.

### `UDPNode`

UDP node class.

#### Annotations

- port: int
- interface: str
- multicast_group: str
- local_peer: Peer | None
- peers: dict[bytes, Peer]
- peer_addrs: dict[tuple[str, int], bytes]
- header_class: type[HeaderProtocol]
- message_type_class: type[IntEnum]
- auth_fields_class: type[AuthFieldsProtocol]
- body_class: type[BodyProtocol]
- message_class: type[MessageProtocol]
- handlers: dict[Hashable, tuple[AnyHandler, AuthPluginProtocol | None,
CipherPluginProtocol | None]]
- ephemeral_handlers: dict[Hashable, tuple[AnyHandler, AuthPluginProtocol |
None, CipherPluginProtocol | None]]
- default_handler: AnyHandler
- extract_keys: Callable[[MessageProtocol, tuple[str, int] | None],
list[Hashable]]
- make_error: Callable[[str], MessageProtocol]
- subscriptions: dict[Hashable, set[tuple[str, int]]]
- logger: logging.Logger
- transport: asyncio.DatagramTransport | None
- auth_plugin: AuthPluginProtocol | None
- cipher_plugin: CipherPluginProtocol | None
- peer_plugin: PeerPluginProtocol | None
- handle_auth_error: AuthErrorHandler
- handle_timeout_error: TimeoutErrorHandler | None
- _timeout_handler_tasks: set[asyncio.Task]
- _timeout_handler_lock: asyncio.Lock

#### Methods

##### `__init__(port: int = 8888, interface: str = '0.0.0.0', multicast_group: str = '224.0.0.1', local_peer: Peer | None = None, header_class: type[HeaderProtocol] = Header, message_type_class: type[IntEnum] = <enum 'MessageType'>, auth_fields_class: type[AuthFieldsProtocol] = AuthFields, body_class: type[BodyProtocol] = Body, message_class: type[MessageProtocol] = Message, default_handler: AnyHandler = <function not_found_handler at 0x78a5047fa340>, extract_keys: Callable[[MessageProtocol, tuple[str, int] | None], list[Hashable]] = <function keys_extractor at 0x78a5050e5e40>, make_error_msg: Callable[[str], MessageProtocol] = <function make_error_msg at 0x78a5047e3740>, logger: logging.Logger = <Logger netaio.node (INFO)>, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None, peer_plugin: PeerPluginProtocol | None = None, auth_error_handler: AuthErrorHandler = <function auth_error_handler at 0x78a5047e3920>, timeout_error_handler: TimeoutErrorHandler | None = None, ignore_own_ip: bool = True):`

Initialize the UDPNode. `port` is the port to listen on. `interface` is the
interface to listen on. `multicast_group` is the multicast group to join.
`local_peer` is the local peer information for this node. `header_class`,
`auth_fields_class`, `body_class`, and `message_class` will be used for sending
messages and parsing responses. `message_type_class` is the class to inject in
calls to the decode method of the header class. `default_handler` is the default
handler to use for messages that do not match any registered handler keys.
`extract_keys` is a function that extracts the keys from a message.
`make_error_msg` is a function that makes an error message. If `auth_plugin` is
provided, it will be used to check the set the `auth_fields` of every sent
message and check authenticity/authorization of all received messages. If
`cipher_plugin` is provided, it will be used to encrypt and decrypt all
messages. If `peer_plugin` is provided, it will be used to encode and decode
peer data. `auth_error_handler` is a function that handles auth errors, i.e.
when an auth check fails for a received message. If it returns a message, that
message will be sent as a response to the sender of the message that failed the
auth check. The default handler returns the error message generated by the auth
plugin and should be replaced if you do not want to send error messages for
failed auth checks (e.g. if the auth plugin is an anti-spam plugin and messages
that fail the auth check should just be dropped). `timeout_error_handler` is a
function that handles timeout errors. It is called with (`self`, `timeout_type`,
`addr`, `error`, `context`) and can perform recovery actions or logging. The
`TimeoutError` is always raised after the handler completes. If `ignore_own_ip`
is `True`, messages from the local IP address will be ignored.

##### `connection_made(transport: asyncio.DatagramTransport):`

Called when a connection is made. The argument is the transport representing the
pipe connection. When the connection is closed, `connection_lost()` is called.
This is called when the UDPNode successfully joins the multicast group.

##### `datagram_received(data: bytes, addr: tuple[str, int]):`

Called when a datagram is received. The arguments are the data received and the
address of the sender. This method will parse the message and call the
appropriate handler, calling plugins as necessary.

##### `error_received(exc: Exception):`

Called when a send or receive operation raises an `OSError`. (Other than
`BlockingIOError` or `InterruptedError`.)

##### `connection_lost(_: Exception):`

Called when the connection is lost or closed. The argument is an exception
object or `None` (the latter meaning a regular EOF is received or the connection
was aborted or closed).

##### `add_handler(key: Hashable, handler: AnyHandler, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return a `MessageProtocol` or
`None`. If an auth plugin is provided, it will be used to check the message in
addition to any auth plugin that is set on the node. If a cipher plugin is
provided, it will be used to decrypt the message in addition to any cipher
plugin that is set on the node. These plugins will also be used for preparing
any response message sent by the handler.

##### `add_ephemeral_handler(key: Hashable, handler: AnyHandler, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Register an ephemeral handler for a specific key. The handler will be removed
either after it is called the first time. Otherwise identical to `add_handler`.

##### `on(key: Hashable, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Decorator to register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return a `MessageProtocol` or
`None`. If an auth plugin is provided, it will be used to check the message in
addition to any auth plugin that is set on the node. If a cipher plugin is
provided, it will be used to decrypt the message in addition to any cipher
plugin that is set on the node. These plugins will also be used for preparing
any response message sent by the handler.

##### `once(key: Hashable, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Decorator to register a one-time handler for a specific key. The handler must
accept a `MessageProtocol` object as an argument and return a `MessageProtocol`
or `None`. If an auth plugin is provided, it will be used to check the message
in addition to any auth plugin that is set on the node. If a cipher plugin is
provided, it will be used to decrypt the message in addition to any cipher
plugin that is set on the node. These plugins will also be used for preparing
any response message sent by the handler.

##### `remove_handler(key: Hashable):`

Remove a handler for a specific key.

##### `remove_ephemeral_handler(key: Hashable):`

Remove an ephemeral handler for a specific key.

##### `subscribe(key: Hashable, addr: tuple[str, int]):`

Subscribe a peer to a specific key. The key must be a Hashable object.

##### `unsubscribe(key: Hashable, addr: tuple[str, int]):`

Unsubscribe a peer from a specific key. If no subscribers are left, the key will
be removed from the subscriptions dictionary.

##### `prepare_message(message: MessageProtocol, /, *, peer: Peer | None = None, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True) -> MessageProtocol | None:`

Prepares a message for transmission by invoking all necessary plugins.

##### `async start():`

Start the UDPNode. When a datagram is received, the `datagram_received` method
is called.

##### `send(message: MessageProtocol, addr: tuple[str, int], /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Send a message to a given address (unicast or multicast). If an auth plugin is
provided, it will be used to authorize the message in addition to any auth
plugin that is set on the node. If a cipher plugin is provided, it will be used
to encrypt the message in addition to any cipher plugin that is set on the node.
If `use_auth` is `False`, the auth plugin set on the node will not be used. If
`use_cipher` is `False`, the cipher plugin set on the node will not be used.

##### `async request(uri: bytes, addr: tuple[str, int], /, *, content: bytes = b'', message_type: MessageType | None = None, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, timeout: float = 10.0) -> MessageProtocol:`

Send a request message and wait for a response. Sets ephemeral handlers for
`OK`, `RESPOND_URI`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types, then
sends a message to the specified address. Waits until a response (success or
error) is received or timeout is reached. If it times out, removes all ephemeral
handlers and raises a `TimeoutError`. If a response is received, returns that
message (caller should check `message.header.message_type` to determine success
or error). When message_type is `None` (default), sends `REQUEST_URI`. Use
`message_type` and content to send `CREATE_URI`, `UPDATE_URI`, or `DELETE_URI`
messages.

##### `async create(uri: bytes, data: bytes, addr: tuple[str, int], /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, timeout: float = 10.0) -> MessageProtocol:`

Send a `CREATE_URI` message and wait for an `OK` response. Sets ephemeral
handlers for `OK`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types, then
sends a `CREATE_URI` message to the specified address. Waits until a response
(success or error) is received or timeout is reached. If it times out, removes
all ephemeral handlers and raises a `TimeoutError`. If a response is received,
returns that message (caller should check `message.header.message_type` to
determine success or error).

##### `async update(uri: bytes, data: bytes, addr: tuple[str, int], /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, timeout: float = 10.0) -> MessageProtocol:`

Send an `UPDATE_URI` message and wait for an `OK` response. Sets ephemeral
handlers for `OK`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types, then
sends an `UPDATE_URI` message to the specified address. Waits until a response
(success or error) is received or timeout is reached. If it times out, removes
all ephemeral handlers and raises a `TimeoutError`. If a response is received,
returns that message (caller should check `message.header.message_type` to
determine success or error).

##### `async delete(uri: bytes, addr: tuple[str, int], /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True, timeout: float = 10.0) -> MessageProtocol:`

Send a `DELETE_URI` message and wait for an `OK` response. Sets ephemeral
handlers for `OK`, `AUTH_ERROR`, `ERROR`, and `NOT_FOUND` message types, then
sends a `DELETE_URI` message to the specified address. Waits until a response
(success or error) is received or timeout is reached. If it times out, removes
all ephemeral handlers and raises a `TimeoutError`. If a response is received,
returns that message (caller should check `message.header.message_type` to
determine success or error).

##### `set_timeout_handler(handler: TimeoutErrorHandler):`

Set or replace the timeout error handler. Experimental and of unknown utility as
of v0.0.9.

##### `async cancel_timeout_handler_tasks():`

Cancel all running timeout handler tasks.

##### `broadcast(message: MessageProtocol, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Send the message to all known peers. If an auth plugin is provided, it will be
used to authorize the message in addition to any auth plugin that is set on the
node. If a cipher plugin is provided, it will be used to encrypt the message in
addition to any cipher plugin that is set on the node. If `use_auth` is `False`,
the auth plugin set on the node will not be used. If `use_cipher` is `False`,
the cipher plugin set on the node will not be used.

##### `multicast(message: MessageProtocol, port: int | None = None, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Send the message to the multicast group. If an auth plugin is provided, it will
be used to authorize the message in addition to any auth plugin that is set on
the node. If a cipher plugin is provided, it will be used to encrypt the message
in addition to any cipher plugin that is set on the node. If `use_auth` is
`False`, the auth plugin set on the node will not be used. If `use_cipher` is
`False`, the cipher plugin set on the node will not be used.

##### `notify(key: Hashable, message: MessageProtocol, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None, use_cipher: bool = True, use_auth: bool = True):`

Send the message to all subscribed peers for the given key concurrently using
`asyncio.gather`. If an auth plugin is provided, it will be used to authorize
the message in addition to any auth plugin that is set on the node. If a cipher
plugin is provided, it will be used to encrypt the message in addition to any
cipher plugin that is set on the node. If `use_auth` is `False`, the auth plugin
set on the node will not be used. If `use_cipher` is `False`, the cipher plugin
set on the node will not be used.

##### `add_or_update_peer(peer_id: bytes, peer_data: bytes, addr: tuple[str, int]) -> bool:`

Add or update a peer in the peer list. If the peer is the local peer, it will
not be added to the peer list. Returns `True` if a `PEER_DISCOVERED` message
should be sent (`False` if it is the local peer).

##### `get_peer(addr: tuple[str, int] | None = None, peer_id: bytes | None = None) -> Peer | None:`

Get a peer from the peer list if addr or peer_id is provided and if it exists.
Prefers `peer_id` if both are provided but will fall back to `addr` if the
provided `peer_id` is not found in the known peers.

##### `remove_peer(addr: tuple[str, int], peer_id: bytes):`

Remove a peer from the peer list and all related subscriptions.

##### `remove_timed_out_peers(timeout: int):`

Remove timed out peers from the peer list.

##### `async begin_peer_advertisement(every: int = 20, app_id: bytes = b'netaio', peer_timeout: int = 60, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Begin peer advertisement. This starts a task that will advertise the local peer
every `every` seconds to the multicast group, and it will use the `app_id` as a
URI to identify the application. The loop will drop any peers that have timed
out. Raises AssertionError if `local_peer` is not set or if the
`message_type_class` does not contain the `ADVERTISE_PEER` message type.

##### `async stop_peer_advertisement(app_id: bytes = b'netaio'):`

Stop the peer advertisement task if it exists.

##### `async manage_peers_automatically(advertise_every: int = 20, app_id: bytes = b'netaio', peer_timeout: int = 60, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Begins automatic peer management. This starts a task that will advertise the
local peer every `advertise_every` seconds to the multicast group, and it will
use the `app_id` as a URI to identify the application. Also registers 3
handlers: 1) for the `ADVERTISE_PEER` message type which will add the peer to
the peer list and respond with a `PEER_DISCOVERED` message to reciprocate; 2)
for the `PEER_DISCOVERED` message that will add the peer to the peer list; and
3) for the `DISCONNECT` message which will remove the peer from the local peer
list. The loop will also drop any peers that have timed out. Raises
`AssertionError` if `local_peer` is not set or if the message_type_class does
not contain `ADVERTISE_PEER`, `PEER_DISCOVERED`, and `DISCONNECT` message types.

##### `async stop_peer_management(app_id: bytes = b'netaio'):`

Stop automatic peer management by stopping peer advertisement and removing the
handlers.

##### `async stop():`

Stop the UDPNode.

##### `set_logger(logger: logging.Logger):`

Replace the current logger.

### `Header`

Default header class.

#### Annotations

- message_type: IntEnum
- auth_length: int
- body_length: int
- checksum: int
- message_type_class: type[IntEnum]

#### Methods

##### `__init__(message_type: IntEnum, auth_length: int, body_length: int, checksum: int, message_type_class: type[IntEnum] = <enum 'MessageType'>):`

##### `@staticmethod header_length() -> int:`

Return the byte length of the header.

##### `@staticmethod struct_fstring() -> str:`

Return the struct format string for decoding the header.

##### `@classmethod decode(data: bytes, message_type_class: type[IntEnum] | None = None) -> Header:`

Decode the header from the `data`.

##### `encode() -> bytes:`

Encode the header into bytes.

### `AuthFields`

Default auth fields class.

#### Annotations

- fields: dict[str, bytes]

#### Methods

##### `__init__(fields: dict[str, bytes] = <factory>):`

##### `@classmethod decode(data: bytes) -> AuthFields:`

Decode the auth fields from bytes.

##### `encode() -> bytes:`

Encode the auth fields into bytes.

### `Body`

Default body class.

#### Annotations

- uri_length: int
- uri: bytes
- content: bytes

#### Methods

##### `__init__(uri_length: int, uri: bytes, content: bytes):`

##### `@classmethod decode(data: bytes) -> Body:`

Decode the body from bytes.

##### `encode() -> bytes:`

Encode the body into bytes.

##### `@classmethod prepare(content: bytes, uri: bytes = b'', overhead: int = 0) -> Body:`

Prepare a body from content and optional arguments. Raises ValueError if the
content + uri is too long. (Calculated by subtracting the header length,
overhead, and 104 from 2**16. The 104 value is for IP encapsulation and other
known sources of overhead.)

### `Message`

Default message class.

#### Annotations

- header: Header
- auth_data: AuthFieldsProtocol
- body: BodyProtocol

#### Methods

##### `__init__(header: Header, auth_data: AuthFieldsProtocol, body: BodyProtocol):`

##### `check() -> bool:`

Check if the message is valid.

##### `@classmethod decode(data: bytes, message_type_class: type[IntEnum] | None = None) -> Message:`

Decode the message from the `data`. Raises `ValueError` if the checksum does not
match.

##### `encode() -> bytes:`

Encode the message into bytes.

##### `copy() -> Message:`

Returns a copy of the message.

##### `@classmethod prepare(body: BodyProtocol, message_type: int, auth_data: AuthFieldsProtocol | None = None) -> Message:`

Prepare a message from a body and optional arguments.

### `MessageType(IntEnum)`

Some default message types: `REQUEST_URI`, `RESPOND_URI`, `CREATE_URI`,
`UPDATE_URI`, `DELETE_URI`, `SUBSCRIBE_URI`, `UNSUBSCRIBE_URI`, `PUBLISH_URI`,
`NOTIFY_URI`, `ADVERTISE_PEER`, `OK`, `CONFIRM_SUBSCRIBE`,
`CONFIRM_UNSUBSCRIBE`, `PEER_DISCOVERED`, `ERROR`, `AUTH_ERROR`, `NOT_FOUND`,
`NOT_PERMITTED`, `DISCONNECT`. Values 0-30 are reserved for base protocol
upgrades. Custom message types must use values >= 31. To create a custom
`IntEnum` for custom network protocols, use the `make_message_type_class`
function to create the type, or use `validate_message_type_class` function to
validate one made with declarative syntax.

### `HeaderProtocol(Protocol)`

Shows what a Header class should have and do.

#### Properties

- body_length: At a minimum, a Header must have `body_length`, `auth_length`,
`message_type`, and `checksum` properties.
- auth_length: At a minimum, a Header must have `body_length`, `auth_length`,
`message_type`, and `checksum` properties.
- message_type: At a minimum, a Header must have `body_length`, `auth_length`,
`message_type`, and `checksum` properties.
- checksum: At a minimum, a Header must have `body_length`, `auth_length`,
`message_type`, and `checksum` properties.

#### Methods

##### `@staticmethod header_length() -> int:`

Return the byte length of the header.

##### `@staticmethod struct_fstring() -> str:`

Return the struct format string for decoding the header.

##### `@classmethod decode(data: bytes, message_type_class: type[IntEnum] | None = None) -> HeaderProtocol:`

Decode the header from the `data`.

##### `encode() -> bytes:`

Encode the header into a `bytes` object.

### `AuthFieldsProtocol(Protocol)`

Shows what an AuthFields class should have and do.

#### Properties

- fields: At a minimum, an AuthFields must have `fields` property.

#### Methods

##### `__init__(fields: dict[str, bytes] = Ellipsis) -> None:`

Initialize auth fields with optional `fields` dict.

##### `@classmethod decode(data: bytes) -> AuthFieldsProtocol:`

Decode the auth fields from the `data`.

##### `encode() -> bytes:`

Encode the auth fields into a `bytes` object.

### `BodyProtocol(Protocol)`

Shows what a Body class should have and do.

#### Properties

- content: At a minimum, a `Body` must have `content`, `uri`, and `uri_length`
properties.
- uri: At a minimum, a `Body` must have `content`, `uri`, and `uri_length`
properties.
- uri_length: At a minimum, a `Body` must have `content`, `uri`, and
`uri_length` properties.

#### Methods

##### `@classmethod decode(data: bytes) -> BodyProtocol:`

Decode the body from the `data`.

##### `encode() -> bytes:`

Encode the body into a `bytes` object.

##### `@classmethod prepare(content: bytes, uri: bytes = b'', overhead: int = 0) -> BodyProtocol:`

Prepare a body from `content` and optional arguments.

### `MessageProtocol(Protocol)`

Shows what a Message class should have and do.

#### Properties

- header: A `Message` must have a `header` property.
- auth_data: A `Message` must have an `auth_data` property.
- body: A `Message` must have a `body` property.

#### Methods

##### `__init__(header: HeaderProtocol, auth_data: AuthFieldsProtocol, body: BodyProtocol) -> None:`

Initialize the message with `header`, `auth_data`, and `body`.

##### `check() -> bool:`

Check if the message is valid.

##### `encode() -> bytes:`

Encode the message into a `bytes` object.

##### `copy() -> MessageProtocol:`

Returns a copy of the message.

##### `@classmethod prepare(body: BodyProtocol, message_type: int, auth_data: AuthFieldsProtocol | None = None) -> MessageProtocol:`

Prepare a message from a body.

### `AuthPluginProtocol(Protocol)`

Shows what an auth plugin should do.

#### Methods

##### `__init__(config: dict):`

Initialize the auth plugin with a config.

##### `make(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> None:`

Set `auth_fields` appropriate for a given body. Optional args `peer` and
`peer_plugin` will be provided if they are available. The local peer information
will be stored in `node.local_peer` if it exists. If `peer`, `peer_plugin`, or
`node.local_peer` are required for functionality but are not provided/set, this
method should fail gracefully: log an error message using `node.logger` (if
provided) and return.

##### `check(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> bool:`

Check if the auth fields are valid for the given body. Optional args peer and
peer_plugin will be provided if they are available. The local peer information
will be stored in node.local_peer if it exists. If peer, peer_plugin, or
node.local_peer are required for functionality but are not provided, this method
should fail gracefully: log an error using node.logger (if provided) and return
False.

##### `error(message_class: type[MessageProtocol] = Ellipsis, message_type_class: type[IntEnum] = Ellipsis, header_class: type[HeaderProtocol] = Ellipsis, auth_fields_class: type[AuthFieldsProtocol] = Ellipsis, body_class: type[BodyProtocol] = Ellipsis) -> MessageProtocol:`

Make an error message.

##### `@staticmethod is_peer_specific() -> bool:`

A cipher plugin must report if it is a peer-specific plugin; i.e. whether or not
it requires peer information to function.

### `CipherPluginProtocol(Protocol)`

Shows what a cipher plugin should do.

#### Methods

##### `__init__(config: dict):`

Initialize the cipher plugin with a config.

##### `encrypt(message: MessageProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> MessageProtocol:`

Encrypt the message `body`, setting values in the `header` or `auth_data` as
necessary. Returns a new message with the encrypted `body` and updated
`auth_data`. Optional args `peer` and `peer_plugin` will be provided if they are
available. The local peer information will be stored in `node.local_peer` if it
exists. If `peer`, `peer_plugin`, or `node.local_peer` are required for
functionality but are not provided, or in the case of an encryption failure,
this method should raise an exception.

##### `decrypt(message: MessageProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> MessageProtocol:`

Decrypt the message body, reading values from the auth_data as necessary.
Returns a new message with the decrypted body. May raise an exception if the
decryption fails. Optional args peer and peer_plugin will be provided if they
are available. The local peer information will be stored in node.local_peer if
it exists. If peer and peer_plugin are required for functionality but are not
provided, or in the case of a decryption failure, this method should raise an
exception.

##### `@staticmethod is_peer_specific() -> bool:`

A cipher plugin must report if it is a peer-specific plugin; i.e. whether or not
it requires peer information to function.

### `PeerPluginProtocol(Protocol)`

Shows what a peer plugin should do.

#### Methods

##### `__init__(config: dict = {}):`

Initialize the peer plugin. Optionally parse a config.

##### `validate(peer: Peer) -> bool:`

Validate a peer. Must return True if the peer is valid, False otherwise, and it
must not raise an exception.

##### `parse_data(peer: Peer) -> dict[str, Any] | NamedTuple:`

Parse a peer's data. Must return a dictionary or namedtuple.

##### `encode_data(peer_data: dict[str, Any] | NamedTuple, peer_id: bytes | None = None) -> bytes:`

Encode a peer's data. Implementation may reference or include the peer_id, but
it should gracefully handle an empty peer_id.

##### `pack(peer: Peer) -> bytes:`

Pack a peer into a bytes object. Does not have to include the addrs.

##### `unpack(data: bytes) -> Peer:`

Unpack a peer from a bytes object. Should set the addrs to an empty set if the
data does not contain any addresses.

### `NetworkNodeProtocol(Protocol)`

For type-hinting objects that handle networking.

#### Properties

- port: A class implementing this protocol must have a `port` property
representing either the port to listen on or the port to connect to.
- local_peer: A class implementing this protocol must have a `local_peer`
property containing the local peer data.
- header_class: A class implementing this protocol must have a `header_class`
property referencing the header class to use for parsing received messages.
- message_type_class: A class implementing this protocol must have a
`message_type_class` property referencing the message type class to use for
parsing received messages.
- auth_fields_class: A class implementing this protocol must have an
`auth_fields_class` property referencing the auth fields class to use for
parsing received messages.
- body_class: A class implementing this protocol must have a `body_class`
property referencing the body class to use for parsing received messages.
- message_class: A class implementing this protocol must have a `message_class`
property referencing the message class to use for parsing received messages.
- handlers: A class implementing this protocol must have a `handlers` property
referencing a dictionary of handler functions, keyed by a hashable object, that
will be called when a message with the corresponding key is received.
- ephemeral_handlers: A class implementing this protocol must have an
`ephemeral_handlers` property referencing a dictionary of one-time handler
functions, keyed by a hashable object, that will be called when a message with
corresponding key is received and then removed.
- default_handler: A class implementing this protocol must have a
`default_handler` property referencing the default handler to use for messages
that do not match any registered handler keys.
- extract_keys: A class implementing this protocol must have an `extract_keys`
property referencing a function that extracts the keys used for routing/choosing
responses from a message.
- make_error: A class implementing this protocol must have a `make_error`
property referencing a function that makes error messages.
- logger: A class implementing this protocol must have a `logger` property
referencing a logger for logging messages.
- auth_plugin: A class implementing this protocol must have an `auth_plugin`
property referencing an auth plugin for authenticating/authorizing messages.
- cipher_plugin: A class implementing this protocol must have a `cipher_plugin`
property referencing a cipher plugin for encrypting and decrypting messages.
- handle_auth_error: A class implementing this protocol must have a
`handle_auth_error` property referencing a function that is called when the auth
check fails for a received message. If the function returns a message, that
message will be sent as a response to the sender of the message that failed the
auth check.

#### Methods

##### `add_handler(key: Hashable, handler: AnyHandler, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return `MessageProtocol | None`. If
an auth plugin is provided, it will be used to check the message in addition to
any auth plugin that is set on the node. If a cipher plugin is provided, it will
be used to decrypt the message in addition to any cipher plugin that is set on
the node. These plugins will also be used for preparing any response message
sent by the handler.

##### `add_ephemeral_handler(key: Hashable, handler: AnyHandler, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Register an ephemeral handler for a specific key. The handler will be removed
after it is called the first time. Otherwise identical to `add_handler`.

##### `on(key: Hashable, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Decorator to register a handler for a specific key. The handler must accept a
`MessageProtocol` object as an argument and return `MessageProtocol | None`. If
an auth plugin is provided, it will be used to check the message in addition to
any auth plugin that is set on the node. If a cipher plugin is provided, it will
be used to decrypt the message in addition to any cipher plugin that is set on
the node. These plugins will also be used for preparing any response message
sent by the handler.

##### `once(key: Hashable, /, *, cipher_plugin: CipherPluginProtocol | None = None, auth_plugin: AuthPluginProtocol | None = None):`

Decorator to register a one-time handler for a specific key. The handler must
accept a `MessageProtocol` object as an argument and return `MessageProtocol`,
`None`, or a coroutine that resolves to a MessageProtocol or None. If an auth
plugin is provided, it will be used to check the message in addition to any auth
plugin that is set on the client. If a cipher plugin is provided, it will be
used to decrypt the message in addition to any cipher plugin that is set on the
client.

##### `remove_handler(key: Hashable):`

Remove a handler from the node.

##### `remove_ephemeral_handler(key: Hashable):`

Remove an ephemeral handler for a specific key.

##### `set_logger(logger: logging.Logger):`

Replace the current logger.

### `Peer`

Class for storing peer information.

#### Annotations

- addrs: set[tuple[str, int]]
- id: bytes | None
- data: bytes | None
- last_rx: int

#### Methods

##### `__init__(addrs: set[tuple[str, int]], id: bytes | None = None, data: bytes | None = None, last_rx: int = <factory>):`

##### `update(data: bytes | None = None):`

Update the peer data and last_rx time.

##### `timed_out(timeout: int = 60) -> bool:`

Check if the peer has timed out.

### `DefaultPeerPlugin`

Default peer plugin.

#### Methods

##### `__init__(config: dict = {}):`

Initialize the peer plugin. No configuration necessary.

##### `validate(peer: Peer) -> bool:`

Validate a peer. By default, accept all peers that have an id.

##### `parse_data(peer: Peer) -> dict[str, Any] | NamedTuple:`

Parse a peer's data. Must return a dictionary or namedtuple.

##### `encode_data(peer_data: dict[str, Any] | NamedTuple, peer_id: bytes | None = None) -> bytes:`

Encode a peer's data. Ignores `peer_id`.

##### `pack(peer: Peer) -> bytes:`

Pack a peer into a bytes object. Does not include addrs.

##### `unpack(data: bytes) -> Peer:`

Unpack a peer from a bytes object. Sets the addrs to an empty set.

### `TimeoutContext(dict)`

#### Annotations

- uri: ForwardRef('bytes', module='netaio.common')
- timeout: ForwardRef('float', module='netaio.common')
- server: ForwardRef('tuple[str, int]', module='netaio.common')
- keys: ForwardRef('Sequence[Hashable]', module='netaio.common')

### `HMACAuthPlugin`

HMAC auth plugin.

#### Annotations

- secret: <class 'bytes'>
- nonce_field: <class 'str'>
- ts_field: <class 'str'>
- hmac_field: <class 'str'>

#### Methods

##### `__init__(config: dict):`

Initialize the HMAC auth plugin with a config. The config must contain
{"secret": <str|bytes>}. It can contain {"hmac_field": <str>} to specify the
auth field name for the hmac; the default is "hmac". It can contain
{"nonce_field": <str>} to specify the auth field name for the nonce; the default
is "nonce". It can contain {"ts_field": <str>} to specify the auth field name
for the timestamp; the default is "ts".

##### `make(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None):`

If the nonce and ts fields are not set, generate them. If the nonce is not the
IV_SIZE, generate a new one. Then, create an hmac of the nonce, ts, and body and
store it in the auth_data field specified by the "hmac_field" config option; the
default is "hmac".

##### `check(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None) -> bool:`

Check if the auth fields are valid for the given body. Performs an hmac check on
the nonce, ts, and body. Returns False if any of the fields are missing or if
the hmac check fails.

##### `error(message_class: type = Message, message_type_class: type = <enum 'MessageType'>, header_class: type = Header, auth_fields_class: type = AuthFields, body_class: type = Body) -> MessageProtocol:`

Make an error message that says "HMAC auth failed".

##### `@staticmethod is_peer_specific() -> bool:`

Used for optimization. Returns `False`.

### `Sha256StreamCipherPlugin`

SHA-256 stream cipher plugin.

#### Annotations

- key: <class 'bytes'>
- iv_field: <class 'str'>
- encrypt_uri: <class 'bool'>

#### Methods

##### `__init__(config: dict):`

Initialize the cipher plugin with a config. The config must contain {"key":
<str|bytes>}. It can contain {"iv_field": <str>} to specify the auth field name
for the iv; the default is "iv". It can contain {"encrypt_uri": <bool>} to
specify whether to encrypt the uri; the default is True.

##### `encrypt(message: MessageProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None) -> MessageProtocol:`

Encrypt the message body, setting the self.iv_field in the auth_data. This will
overwrite any existing value in that auth_data field. If the self.encrypt_uri is
True, the uri will be encrypted as well as the content.

##### `decrypt(message: MessageProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None) -> MessageProtocol:`

Decrypt the message body, reading the self.iv_field from the auth_data. Returns
a new message with the decrypted body.

##### `@staticmethod is_peer_specific() -> bool:`

Used for optimization. Returns `False`.

## Functions

### `keys_extractor(message: MessageProtocol, host: tuple[str, int] | None = None) -> list[Hashable]:`

Extract handler keys for a given message. Custom implementations should return
at least one key, and the more specific keys should be listed first. This is
used to determine which handler to call for a given message, and it returns two
keys: one that includes both the message type and the body uri, and one that is
just the message type.

### `make_respond_uri_msg(content: str | bytes, uri: bytes, /, *, body_class: type[BodyProtocol] = Body, message_type_class: type[IntEnum] = <enum 'MessageType'>, message_class: type[MessageProtocol] = Message) -> MessageProtocol:`

Create a RESPOND_URI message with content and URI.

### `make_ok_msg(content: str | bytes = b'', uri: bytes = b'', /, *, body_class: type[BodyProtocol] = Body, message_type_class: type[IntEnum] = <enum 'MessageType'>, message_class: type[MessageProtocol] = Message) -> MessageProtocol:`

Create an OK message with optional content and URI.

### `make_error_msg(msg: str | bytes, uri: bytes = b'ERROR', /, *, body_class: type[BodyProtocol] = Body, message_type_class: type[IntEnum] = <enum 'MessageType'>, message_class: type[MessageProtocol] = Message, message_type: int | None = None) -> MessageProtocol:`

Make an error message.

### `make_not_found_msg(msg: str | bytes = 'not found', uri: bytes = b'', /, *, body_class: type[BodyProtocol] = Body, message_type_class: type[IntEnum] = <enum 'MessageType'>, message_class: type[MessageProtocol] = Message) -> MessageProtocol:`

Create a NOT_FOUND message with optional error message and URI.

### `make_not_permitted_msg(msg: str | bytes = 'not permitted', uri: bytes = b'', /, *, body_class: type[BodyProtocol] = Body, message_type_class: type[IntEnum] = <enum 'MessageType'>, message_class: type[MessageProtocol] = Message) -> MessageProtocol:`

Create a NOT_PERMITTED message with optional error message and URI.

### `validate_message_type_class(message_type_class: type[IntEnum], /, *, suppress_errors: bool = False) -> bool:`

Validates a message type class. Raises `ValueError` for missing or redefined
default message types, or for custom types using reserved values (0-30), or
`TypeError` for a non-`type[IntEnum]` if `suppress_errors` is not made `True`.
Returns `True` if it is valid and `False` otherwise.

### `make_message_type_class(name: str, new_message_types: dict[str, int]) -> type[IntEnum]:`

Makes a valid `IntEnum` that is essentially a subclass of MessageType,
containing all the required default message types. Raises `ValueError` if one of
the `new_message_types` attempts to overwrite a built-in message type or use a
reserved value (0-30) for forward-compabitility between uses of this library.

### `version() -> str:`

Return the version of the netaio package.

## Values

- `Handler`: _CallableGenericAlias
- `UDPHandler`: _CallableGenericAlias
- `AuthErrorHandler`: _CallableGenericAlias
- `TimeoutErrorHandler`: _CallableGenericAlias
- `default_server_logger`: Logger
- `default_client_logger`: Logger
- `default_node_logger`: Logger

