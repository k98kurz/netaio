from __future__ import annotations
from .common import (
    Header,
    AuthFields,
    Body,
    Message,
    MessageType,
    MessageTypeClassProtocol,
    HeaderProtocol,
    AuthFieldsProtocol,
    BodyProtocol,
    MessageProtocol,
    AuthPluginProtocol,
    CipherPluginProtocol,
    PeerPluginProtocol,
    Peer,
    get_ip,
    keys_extractor,
    make_error_response,
    auth_error_handler,
    AnyHandler,
    AuthErrorHandler,
    TimeoutErrorHandler,
    DefaultPeerPlugin,
    default_node_logger,
    UDPHandler,
)
from enum import IntEnum
from time import time
from typing import Any, Callable, Coroutine, Hashable, cast
import asyncio
import socket
import logging


def not_found_handler(*_) -> MessageProtocol | None:
    return make_error_response("not found")


class UDPNode:
    """UDP node class."""
    port: int
    interface: str
    multicast_group: str
    local_peer: Peer | None
    peers: dict[bytes, Peer]
    peer_addrs: dict[tuple[str, int], bytes]
    header_class: type[HeaderProtocol]
    message_type_class: type[Any]
    auth_fields_class: type[AuthFieldsProtocol]
    body_class: type[BodyProtocol]
    message_class: type[MessageProtocol]
    handlers: dict[
        Hashable,
        tuple[AnyHandler, AuthPluginProtocol|None, CipherPluginProtocol|None]
    ]
    ephemeral_handlers: dict[
        Hashable,
        tuple[AnyHandler, AuthPluginProtocol|None, CipherPluginProtocol|None]
    ]
    default_handler: AnyHandler
    extract_keys: Callable[[MessageProtocol, tuple[str, int] | None], list[Hashable]]
    make_error: Callable[[str], MessageProtocol]
    subscriptions: dict[Hashable, set[tuple[str, int]]]
    logger: logging.Logger
    transport: asyncio.DatagramTransport | None
    auth_plugin: AuthPluginProtocol | None
    cipher_plugin: CipherPluginProtocol | None
    peer_plugin: PeerPluginProtocol | None
    handle_auth_error: AuthErrorHandler
    handle_timeout_error: TimeoutErrorHandler | None
    _timeout_handler_tasks: set[asyncio.Task]
    _timeout_handler_lock: asyncio.Lock

    def __init__(
            self,
            port: int = 8888,
            interface: str = '0.0.0.0',
            multicast_group: str = '224.0.0.1',
            local_peer: Peer | None = None,
            header_class: type[HeaderProtocol] = Header,
            message_type_class: type[Any] = MessageType,
            auth_fields_class: type[AuthFieldsProtocol] = AuthFields,
            body_class: type[BodyProtocol] = Body,
            message_class: type[MessageProtocol] = Message,
            default_handler: AnyHandler = not_found_handler,
            extract_keys: Callable[
                [MessageProtocol, tuple[str, int] | None],
                list[Hashable]
            ] = keys_extractor,
            make_error_response: Callable[
                [str], MessageProtocol
            ] = make_error_response,
            logger: logging.Logger = default_node_logger,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None,
            peer_plugin: PeerPluginProtocol | None = None,
            auth_error_handler: AuthErrorHandler = auth_error_handler,
            timeout_error_handler: TimeoutErrorHandler | None = None,
            ignore_own_ip: bool = True,
        ):
        """Initialize the UDPNode.
            `port` is the port to listen on.
            `interface` is the interface to listen on.
            `multicast_group` is the multicast group to join.
            `local_peer` is the local peer information for this node.
            `header_class`, `auth_fields_class`, `body_class`, and
            `message_class` will be used for sending messages and
            parsing responses.
            `message_type_class` is the class to inject in calls to the
            decode method of the header class.
            `default_handler` is the default handler to use for messages
            that do not match any registered handler keys.
            `extract_keys` is a function that extracts the keys from a
            message.
            `make_error_response` is a function that makes an error
            response.
            If `auth_plugin` is provided, it will be used to check the
            set the auth_fields of every sent message and check
            authenticity/authorization of all received messages.
            If `cipher_plugin` is provided, it will be used to encrypt
            and decrypt all messages.
            If `peer_plugin` is provided, it will be used to encode and
            decode peer data.
            `auth_error_handler` is a function that handles auth errors,
            i.e. when an auth check fails for a received message. If it
            returns a message, that message will be sent as a response
            to the sender of the message that failed the auth check. The
            default handler returns the error message generated by the
            auth plugin and should be replaced if you do not want to
            send error messages for failed auth checks (e.g. if the
            auth plugin is an anti-spam plugin and messages that fail
            the auth check should just be dropped).
            `timeout_error_handler` is a function that handles timeout
            errors. It is called with (self, timeout_type, server, error,
            context) and can perform recovery actions or logging. The
            TimeoutError is always raised after the handler completes.
            If `ignore_own_ip` is True, messages from the local IP
            address will be ignored.
        """
        self.peers = {}
        self.peer_addrs = {}
        self.port = port
        self.interface = interface
        self.multicast_group = multicast_group
        self.local_peer = local_peer
        self.header_class = header_class
        self.message_type_class = message_type_class
        self.auth_fields_class = auth_fields_class
        self.body_class = body_class
        self.message_class = message_class
        self.handlers = {}
        self.ephemeral_handlers = {}
        self.default_handler = default_handler
        self.extract_keys = extract_keys
        self.make_error = make_error_response
        self.auth_plugin = auth_plugin
        self.cipher_plugin = cipher_plugin
        self.peer_plugin = peer_plugin or DefaultPeerPlugin()
        self.handle_auth_error = auth_error_handler
        self.handle_timeout_error = timeout_error_handler
        self.logger = logger
        self.transport = None
        self.subscriptions = {}
        self._advertise_peer_tasks: dict[bytes, asyncio.Task] = {}
        self._timeout_handler_tasks = set()
        self._timeout_handler_lock = asyncio.Lock()
        self._local_ip = get_ip() if ignore_own_ip else None

    def connection_made(self, transport: asyncio.DatagramTransport):
        """Called when a connection is made. The argument is the
            transport representing the pipe connection. When the
            connection is closed, connection_lost() is called. This is
            called when the UDPNode successfully joins the multicast
            group.
        """
        sock: socket.socket = transport.get_extra_info("socket")
        mreq = socket.inet_aton(self.multicast_group) + socket.inet_aton(self.interface)
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
        self.logger.info(
            f"UDPNode joined multicast group {self.multicast_group} on port "
            f"{self.port}"
        )

    def datagram_received(self, data: bytes, addr: tuple[str, int]):
        """Called when a datagram is received. The arguments are the
            data received and the address of the sender. This method
            will parse the message and call the appropriate handler,
            calling plugins as necessary.
        """
        if addr[0] == self._local_ip:
            self.logger.debug("Received datagram from self, ignoring")
            return
        self.logger.debug(f"Received datagram from {addr}")
        cipher_plugin, auth_plugin = None, None
        peer_id = self.peer_addrs.get(addr)
        peer = self.peers.get(peer_id) if peer_id is not None else None

        header_bytes = data[:self.header_class.header_length()]
        data = data[self.header_class.header_length():]
        header: HeaderProtocol = self.header_class.decode(
            header_bytes,
            message_type_factory=self.message_type_class
        )

        auth_bytes = data[:header.auth_length]
        data = data[header.auth_length:]
        auth: AuthFieldsProtocol = self.auth_fields_class.decode(auth_bytes)

        body_bytes = data[:header.body_length]
        body: BodyProtocol = self.body_class.decode(body_bytes)

        message: MessageProtocol = self.message_class(
            header=header,
            auth_data=auth,
            body=body
        )
        self.logger.debug(
            "Received message with checksum=%s from %s",
            message.header.checksum, addr
        )

        if not message.check():
            self.logger.debug("Invalid message received from %s", addr)
            response: MessageProtocol | None = self.make_error("invalid message")
            if response is not None:
                self.send(response, addr, use_auth=False, use_cipher=False)
            return

        # outer auth
        if self.auth_plugin is not None:
            self.logger.debug("Calling self.auth_plugin.check on auth and body")
            check = self.auth_plugin.check(
                message.auth_data, message.body, self, peer, self.peer_plugin
            )
            if not check:
                self.logger.warning("Message auth failed")
                response = self.handle_auth_error(
                    self, self.auth_plugin, message
                )
                if response is not None:
                    self.send(response, addr, use_auth=False, use_cipher=False)
                return
            self.logger.debug("Valid auth_fields received from %s", addr)

        # outer cipher
        if self.cipher_plugin is not None:
            self.logger.debug("Calling self.cipher_plugin.decrypt on message")
            try:
                message = self.cipher_plugin.decrypt(
                    message, self, peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.warning("Error decrypting message: %s; dropping", e)
                return

        keys = self.extract_keys(message, addr)
        self.logger.debug("Message received from %s with keys=%s", addr, keys)

        for key in keys:
            if key in self.handlers or key in self.ephemeral_handlers:
                if key in self.ephemeral_handlers:
                    (
                        handler, auth_plugin, cipher_plugin
                    ) = self.ephemeral_handlers.pop(key)
                else:
                    handler, auth_plugin, cipher_plugin = self.handlers[key]

                # inner auth
                if auth_plugin is not None:
                    self.logger.debug("Calling auth_plugin.check on auth and body")
                    check = auth_plugin.check(
                        message.auth_data, message.body, self, peer, self.peer_plugin
                    )
                    if not check:
                        self.logger.warning("Message auth failed")
                        response = self.handle_auth_error(
                            self, auth_plugin, message
                        )
                        if response is not None:
                            self.send(response, addr, use_auth=False, use_cipher=False)
                        return
                    self.logger.debug("Valid inner auth_fields received from %s", addr)

                # inner cipher
                if cipher_plugin is not None:
                    self.logger.debug("Calling cipher_plugin.decrypt on message")
                    try:
                        message = cipher_plugin.decrypt(
                            message, self, peer, self.peer_plugin
                        )
                    except Exception as e:
                        self.logger.warning(
                            "Error decrypting message; dropping", exc_info=True
                        )
                        return

                self.logger.debug(
                    "Calling handler with message and addr for key=%s", key
                )
                udp_handler = cast(UDPHandler, handler)
                response_or_coro: MessageProtocol | Coroutine[Any, Any, MessageProtocol | None] | None = udp_handler(message, addr)
                response = response_or_coro if isinstance(response_or_coro, MessageProtocol) else None
                break
        else:
            self.logger.warning(
                "No handler found for keys=%s, calling default handler", keys
            )
            udp_default_handler = cast(UDPHandler, self.default_handler)
            default_response_or_coro: MessageProtocol | Coroutine[Any, Any, MessageProtocol | None] | None = udp_default_handler(message, addr)
            response = default_response_or_coro if isinstance(default_response_or_coro, MessageProtocol) else None

        if response is not None:
            # if the sender is a peer, update that peer timestamp
            peer_id = self.peer_addrs.get(addr, None)
            if peer_id is not None:
                peer = self.peers.get(peer_id) if peer_id is not None else None
                if peer is not None:
                    peer.update()

            # inner cipher
            if cipher_plugin is not None:
                self.logger.debug(
                    "Calling cipher_plugin.encrypt on response (handler)"
                )
                try:
                    response = cipher_plugin.encrypt(
                        response, self, peer, self.peer_plugin
                    )
                except Exception as e:
                    self.logger.warning("Error encrypting response: %s; dropping", e)
                    return

            # inner auth
            if auth_plugin is not None:
                self.logger.debug(
                    "Calling auth_plugin.make on response.body (handler)"
                )
                auth_plugin.make(
                    response.auth_data, response.body, self, peer, self.peer_plugin
                )

            # outer cipher
            if self.cipher_plugin is not None:
                self.logger.debug("Calling self.cipher_plugin.encrypt on response")
                try:
                    response = self.cipher_plugin.encrypt(
                        response, self, peer, self.peer_plugin
                    )
                except Exception as e:
                    self.logger.warning("Error encrypting response: %s; dropping", e)
                    return

            # outer auth
            if self.auth_plugin is not None:
                self.logger.debug("Calling self.auth_plugin.make on response.body")
                self.auth_plugin.make(
                    response.auth_data, response.body, self, peer, self.peer_plugin
                )

            self.send(response, addr, use_auth=False, use_cipher=False)

    def error_received(self, exc: Exception):
        """Called when a send or receive operation raises an OSError.
            (Other than BlockingIOError or InterruptedError.)
        """
        self.logger.error(f"Error received: {exc}")

    def connection_lost(self, _: Exception):
        """Called when the connection is lost or closed. The argument is
            an exception object or None (the latter meaning a regular
            EOF is received or the connection was aborted or closed).
        """
        self.logger.info("Connection closed")

    def add_handler(
            self, key: Hashable, handler: AnyHandler, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Register a handler for a specific key. The handler must
            accept a MessageProtocol object as an argument and return a
            MessageProtocol or None. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the node. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the node. These
            plugins will also be used for preparing any response
            message sent by the handler.
        """
        self.logger.debug("Adding handler for key=%s", key)
        self.handlers[key] = (handler, auth_plugin, cipher_plugin)

    def add_ephemeral_handler(
            self, key: Hashable, handler: AnyHandler, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Register an ephemeral handler for a specific key. The handler
            will be removed either after it is called the first time.
            Otherwise identical to `add_handler`.
        """
        self.logger.debug("Adding ephemeral handler for key=%s", key)
        self.ephemeral_handlers[key] = (handler, auth_plugin, cipher_plugin)

    def on(
            self, key: Hashable, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Decorator to register a handler for a specific key. The handler must
            accept a MessageProtocol object as an argument and return a
            MessageProtocol or None. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the node. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the node. These
            plugins will also be used for preparing any response
            message sent by the handler.
        """
        def decorator(func: AnyHandler):
            self.add_handler(
                key, func, auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )
            return func
        return decorator

    def once(
            self, key: Hashable, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Decorator to register a one-time handler for a specific key.
            The handler must accept a MessageProtocol object as an
            argument and return a MessageProtocol or None. If an auth
            plugin is provided, it will be used to check the message in
            addition to any auth plugin that is set on the node. If a
            cipher plugin is provided, it will be used to decrypt the
            message in addition to any cipher plugin that is set on the
            node. These plugins will also be used for preparing any
            response message sent by the handler.
        """
        def decorator(func: AnyHandler):
            self.add_ephemeral_handler(
                key, func, auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )
            return func
        return decorator

    def remove_handler(self, key: Hashable):
        """Remove a handler for a specific key."""
        self.logger.debug("Removing handler for key=%s", key)
        if key in self.handlers:
            del self.handlers[key]

    def remove_ephemeral_handler(self, key: Hashable):
        """Remove an ephemeral handler for a specific key."""
        self.logger.debug("Removing ephemeral handler for key=%s", key)
        if key in self.ephemeral_handlers:
            del self.ephemeral_handlers[key]

    def subscribe(self, key: Hashable, addr: tuple[str, int]):
        """Subscribe a peer to a specific key. The key must be a
            Hashable object.
        """
        self.logger.debug("Subscribing peer to key=%s", key)
        if key not in self.subscriptions:
            self.subscriptions[key] = set()
        self.subscriptions[key].add(addr)

    def unsubscribe(self, key: Hashable, addr: tuple[str, int]):
        """Unsubscribe a peer from a specific key. If no subscribers
            are left, the key will be removed from the subscriptions
            dictionary.
        """
        self.logger.debug("Unsubscribing peer from key=%s", key)
        if key in self.subscriptions:
            self.subscriptions[key].remove(addr)
            if not self.subscriptions[key]:
                del self.subscriptions[key]

    def prepare_message(
        self, message: MessageProtocol, *,
        use_auth: bool = True, use_cipher: bool = True,
        auth_plugin: AuthPluginProtocol|None = None,
        cipher_plugin: CipherPluginProtocol|None = None, peer: Peer|None = None,
    ) -> MessageProtocol|None:
        """Prepares a message for transmission by invoking all necessary
            plugins.
        """
        # inner cipher
        if cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.encrypt on message")
            try:
                message = cipher_plugin.encrypt(
                    message, self, peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error encrypting message; dropping", exc_info=True
                )
                return None

        # inner auth
        if auth_plugin is not None:
            self.logger.debug("Calling auth_plugin.make on auth_data and body")
            try:
                auth_plugin.make(
                    message.auth_data, message.body, self, peer,
                    self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error making message; dropping", exc_info=True
                )
                return None

        # outer cipher
        if use_cipher and self.cipher_plugin is not None:
            self.logger.debug("Calling self.cipher_plugin.encrypt on message")
            try:
                message = self.cipher_plugin.encrypt(
                    message, self, peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error encrypting message; dropping", exc_info=True
                )
                return None

        # outer auth
        if use_auth and self.auth_plugin is not None:
            self.logger.debug(
                "Calling self.auth_plugin.make on auth_data and body"
            )
            try:
                self.auth_plugin.make(
                    message.auth_data, message.body, self, peer,
                    self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error making message; dropping", exc_info=True
                )
                return None

        return message

    async def start(self):
        """Start the UDPNode. When a datagram is received, the
            datagram_received method is called.
        """
        loop = asyncio.get_running_loop()
        self.transport, protocol = await loop.create_datagram_endpoint(
            lambda: self,
            local_addr=(self.interface, self.port),
            family=socket.AF_INET
        )
        self.logger.info(f"UDPNode started on port {self.port}")

    def send(
            self, message: MessageProtocol, addr: tuple[str, int], *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send a message to a given address (unicast or multicast).
            If an auth plugin is provided, it will be used to authorize
            the message in addition to any auth plugin that is set on
            the node. If a cipher plugin is provided, it will be used to
            encrypt the message in addition to any cipher plugin that is
            set on the node. If use_auth is False, the auth plugin set
            on the node will not be used. If use_cipher is False, the
            cipher plugin set on the node will not be used.
        """
        peer_id = self.peer_addrs.get(addr, None)
        peer = self.peers.get(peer_id) if peer_id is not None else None
        prepared_msg: MessageProtocol | None = self.prepare_message(
            message, use_auth=use_auth, use_cipher=use_cipher,
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
            peer=peer,
        )
        if prepared_msg is None:
            return
        data = prepared_msg.encode()
        if self.transport is None:
            return
        self.transport.sendto(data, addr)
        self.logger.debug(
            f"Sent message with checksum={message.header.checksum} to {addr}"
        )

    async def request(
            self, uri: bytes,
            server: tuple[str, int], *,
            timeout: float = 10.0,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None,
            message_type: MessageType|None = None,
            content: bytes = b'',
        ) -> MessageProtocol:
        """Send a request message and wait for a response.
            Sets ephemeral handlers for OK, RESPOND_URI, AUTH_ERROR, ERROR, and
            NOT_FOUND message types, then sends a message to the specified
            address. Waits until a response (success or error) is received or
            timeout is reached. If it times out, removes all ephemeral
            handlers and raises a TimeoutError. If a response is received,
            returns that message (caller should check message.header.message_type
            to determine success or error).

            When message_type is None (default), sends REQUEST_URI. Use message_type
            and content to send CREATE_URI, UPDATE_URI, or DELETE_URI messages.
        """
        result = []
        message_type = message_type or self.message_type_class.REQUEST_URI

        keys = [
            (self.message_type_class.AUTH_ERROR, uri, server),
            (self.message_type_class.ERROR, uri, server),
        ]

        if message_type == self.message_type_class.REQUEST_URI:
            keys.append((self.message_type_class.RESPOND_URI, uri, server))
        else:
            keys.append((self.message_type_class.OK, uri, server))

        if message_type != self.message_type_class.CREATE_URI:
            keys.append((self.message_type_class.NOT_FOUND, uri, server))

        event = asyncio.Event()

        def make_handler(my_key):
            def handle_any_response(
                message: MessageProtocol,
                addr: tuple[str, int]
            ):
                result.append(message)
                event.set()
                for other_key in keys:
                    if other_key != my_key:
                        self.remove_ephemeral_handler(other_key)
            return handle_any_response

        for key in keys:
            handler = make_handler(key)
            self.add_ephemeral_handler(
                key, handler, auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )

        request_body = self.body_class.prepare(content=content, uri=uri)
        request_message = self.message_class.prepare(
            request_body, message_type
        )
        self.send(
            request_message, server,
            use_auth=use_auth, use_cipher=use_cipher,
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )

        try:
            await asyncio.wait_for(event.wait(), timeout=timeout)
        except asyncio.TimeoutError:
            for key in keys:
                self.remove_ephemeral_handler(key)
            error = TimeoutError(
                f"Request for URI {uri.decode('utf-8', errors='replace')} @ " +
                f"{server} timed out after {timeout}s"
            )
            context = {
                'uri': uri,
                'timeout': timeout,
                'server': server,
                'keys': keys
            }
            await self._invoke_timeout_handler(
                'request_timeout', server, error, context
            )
            raise error

        return result[0]

    async def create(
            self, uri: bytes, data: bytes, server: tuple[str, int], *,
            timeout: float = 10.0,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol:
        """Send a CREATE_URI message and wait for an OK response.
            Sets ephemeral handlers for OK, AUTH_ERROR, ERROR, and
            NOT_FOUND message types, then sends a CREATE_URI message
            to the specified address. Waits until a response (success or
            error) is received or timeout is reached. If it times out,
            removes all ephemeral handlers and raises a TimeoutError. If a
            response is received, returns that message (caller should check
            message.header.message_type to determine success or error).
        """
        return await self.request(
            uri, server,
            timeout=timeout,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin,
            message_type=self.message_type_class.CREATE_URI,
            content=data
        )

    async def update(
            self, uri: bytes, data: bytes,
            server: tuple[str, int], *,
            timeout: float = 10.0,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol:
        """Send an UPDATE_URI message and wait for an OK response.
            Sets ephemeral handlers for OK, AUTH_ERROR, ERROR, and
            NOT_FOUND message types, then sends an UPDATE_URI message
            to the specified address. Waits until a response (success or
            error) is received or timeout is reached. If it times out,
            removes all ephemeral handlers and raises a TimeoutError. If a
            response is received, returns that message (caller should check
            message.header.message_type to determine success or error).
        """
        return await self.request(
            uri, server,
            timeout=timeout,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin,
            message_type=self.message_type_class.UPDATE_URI,
            content=data
        )

    async def delete(
            self, uri: bytes,
            server: tuple[str, int], *,
            timeout: float = 10.0,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol:
        """Send a DELETE_URI message and wait for an OK response.
            Sets ephemeral handlers for OK, AUTH_ERROR, ERROR, and
            NOT_FOUND message types, then sends a DELETE_URI message
            to the specified address. Waits until a response (success or
            error) is received or timeout is reached. If it times out,
            removes all ephemeral handlers and raises a TimeoutError. If a
            response is received, returns that message (caller should check
            message.header.message_type to determine success or error).
        """
        return await self.request(
            uri, server,
            timeout=timeout,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin,
            message_type=self.message_type_class.DELETE_URI
        )

    def set_timeout_handler(self, handler: TimeoutErrorHandler):
        """Set or replace the timeout error handler. Experimental
            and of unknown utility as of v0.0.9.
        """
        self.handle_timeout_error = handler

    async def _invoke_timeout_handler(
            self,
            timeout_type: str,
            server: tuple[str, int] | None,
            error: TimeoutError,
            context: dict[str, Any]
    ):
        """Invoke the timeout error handler with sync/async handling."""
        if self.handle_timeout_error is None:
            return

        result = self.handle_timeout_error(
            self, timeout_type, server, error, context
        )

        if isinstance(result, Coroutine):
            task = asyncio.create_task(result)
            self._timeout_handler_tasks.add(task)
            task.add_done_callback(self._timeout_handler_tasks.discard)

    async def cancel_timeout_handler_tasks(self):
        """Cancel all running timeout handler tasks."""
        async with self._timeout_handler_lock:
            for task in list(self._timeout_handler_tasks):
                task.cancel()
            await asyncio.gather(*self._timeout_handler_tasks, return_exceptions=True)
            self._timeout_handler_tasks.clear()

    def broadcast(
            self, message: MessageProtocol, *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send the message to all known peers. If an auth plugin is
            provided, it will be used to authorize the message in
            addition to any auth plugin that is set on the node. If a
            cipher plugin is provided, it will be used to encrypt the
            message in addition to any cipher plugin that is set on the
            node. If use_auth is False, the auth plugin set on the
            node will not be used. If use_cipher is False, the cipher
            plugin set on the node will not be used.
        """
        self.logger.debug("Broadcasting message to all peers")
        messages = []
        peer_ids = set()
        prepared_msg: MessageProtocol | None = None

        # check if any plugin is peer-specific
        peer_specific = False
        if use_auth and self.auth_plugin and self.auth_plugin.is_peer_specific():
            peer_specific = True
        if use_cipher and self.cipher_plugin and self.cipher_plugin.is_peer_specific():
            peer_specific = True
        if auth_plugin and auth_plugin.is_peer_specific():
            peer_specific = True
        if cipher_plugin and cipher_plugin.is_peer_specific():
            peer_specific = True

        if not peer_specific:
            prepared_msg = self.prepare_message(
                message, use_auth=use_auth, use_cipher=use_cipher,
                auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
            )
            if not prepared_msg:
                return

        for addr, peer_id in self.peer_addrs.items():
            # only send to each peer once, regardless of how many addrs it has
            if peer_id in peer_ids:
                continue
            peer_ids.add(peer_id)
            peer = self.peers.get(peer_id) if peer_id is not None else None
            if peer_specific:
                msg = self.prepare_message(
                    message.copy(), use_auth=use_auth, use_cipher=use_cipher,
                    auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
                    peer=peer,
                )
            else:
                msg = prepared_msg
            if msg:
                messages.append((addr, msg))

        for addr, msg in messages:
            self.send(msg, addr, use_auth=False, use_cipher=False)

    def multicast(
            self, message: MessageProtocol, port: int|None = None, *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send the message to the multicast group. If an auth plugin is
            provided, it will be used to authorize the message in
            addition to any auth plugin that is set on the node. If a
            cipher plugin is provided, it will be used to encrypt the
            message in addition to any cipher plugin that is set on the
            node. If use_auth is False, the auth plugin set on the
            node will not be used. If use_cipher is False, the cipher
            plugin set on the node will not be used.
        """
        self.logger.debug("Multicasting message to the multicast group")
        prepared_msg: MessageProtocol | None = self.prepare_message(
            message, use_auth=use_auth, use_cipher=use_cipher,
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
        )
        if not prepared_msg:
            return
        addr = (self.multicast_group, port or self.port)
        self.send(prepared_msg, addr, use_auth=False, use_cipher=False)

    def notify(
            self, key: Hashable, message: MessageProtocol, *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send the message to all subscribed peers for the given key
            concurrently using asyncio.gather. If an auth plugin is
            provided, it will be used to authorize the message in
            addition to any auth plugin that is set on the node. If a
            cipher plugin is provided, it will be used to encrypt the
            message in addition to any cipher plugin that is set on
            the node. If use_auth is False, the auth plugin set on the
            node will not be used. If use_cipher is False, the
            cipher plugin set on the node will not be used.
        """
        if key not in self.subscriptions:
            self.logger.debug(
                "No subscribers found for key=%s, skipping notification", key
            )
            return

        self.logger.debug(
            "Notifying %d peers for key=%s", len(self.subscriptions[key]), key
        )

        subscribers = self.subscriptions.get(key, set())
        if not subscribers:
            self.logger.debug(
                "No subscribers found for key=%s, removing from subscriptions", key
            )
            del self.subscriptions[key]
            return

        # check if any plugin is peer-specific
        peer_specific = False
        if use_auth and self.auth_plugin and self.auth_plugin.is_peer_specific():
            peer_specific = True
        if use_cipher and self.cipher_plugin and self.cipher_plugin.is_peer_specific():
            peer_specific = True
        if auth_plugin and auth_plugin.is_peer_specific():
            peer_specific = True
        if cipher_plugin and cipher_plugin.is_peer_specific():
            peer_specific = True

        prepared_msg: MessageProtocol | None = None
        if not peer_specific:
            prepared_msg = self.prepare_message(
                message, use_auth=use_auth, use_cipher=use_cipher,
                auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )
            if not prepared_msg:
                return

        for addr in subscribers:
            peer_id = self.peer_addrs.get(addr, None)
            peer = self.peers.get(peer_id) if peer_id is not None else None
            if peer_specific:
                msg = self.prepare_message(
                    message.copy(), use_auth=use_auth, use_cipher=use_cipher,
                    auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
                    peer=peer
                )
            else:
                msg = prepared_msg

            if msg:
                self.send(msg, addr, use_auth=False, use_cipher=False)

        self.logger.debug("Notified %d peers for key=%s", len(subscribers), key)

    def add_or_update_peer(
            self, peer_id: bytes, peer_data: bytes, addr: tuple[str, int]
        ) -> bool:
        """Add or update a peer in the peer list. If the peer is the
            local peer, it will not be added to the peer list. Returns
            True if a PEER_DISCOVERED message should be sent (False if
            it is the local peer).
        """
        if self.local_peer is not None and peer_id == self.local_peer.id:
            self.logger.debug("Ignoring local peer.")
            return False
        if peer_id in self.peers:
            self.logger.debug(
                "Updating peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id].update(peer_data)
            self.peers[peer_id].addrs.add(addr)
        else:
            self.logger.debug(
                "Adding peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id] = Peer({addr}, peer_id, peer_data)
        self.peer_addrs[addr] = peer_id
        return True

    def get_peer(
            self, addr: tuple[str, int]|None = None, peer_id: bytes|None = None
        ) -> Peer|None:
        """Get a peer from the peer list if addr or peer_id is provided
            and if it exists. Prefers peer_id if both are provided but
            will fall back to addr if the provided peer_id is not found.
        """
        peer = None
        if peer_id is not None:
            peer = self.peers.get(peer_id) if peer_id is not None else None
        if addr is not None and peer is None:
            peer_id = self.peer_addrs.get(addr, None)
            peer = self.peers.get(peer_id) if peer_id is not None else None
        return peer

    def remove_peer(self, addr: tuple[str, int], peer_id: bytes):
        """Remove a peer from the peer list and all related subscriptions."""
        self.logger.debug(
            "Removing peer 0x%s at %s from peer list", peer_id.hex(), addr
        )
        if peer_id in self.peers:
            peer = self.peers[peer_id]
            del self.peers[peer_id]
            for addr in peer.addrs:
                if addr in self.subscriptions:
                    del self.subscriptions[addr]
        if addr in self.peer_addrs:
            del self.peer_addrs[addr]
        for key in self.subscriptions:
            if addr in self.subscriptions[key]:
                self.subscriptions[key].remove(addr)

    def remove_timed_out_peers(self, timeout: int):
        """Remove timed out peers from the peer list."""
        peers_to_remove = []
        for addr, peer_id in self.peer_addrs.items():
            if peer_id not in self.peers:
                peers_to_remove.append((addr, peer_id))
                continue
            if self.peers[peer_id].timed_out(timeout):
                peers_to_remove.append((addr, peer_id))

        for addr, peer_id in peers_to_remove:
            self.remove_peer(addr, peer_id)

    async def begin_peer_advertisement(
            self, every: int = 20, app_id: bytes = b'netaio',
            peer_timeout: int = 60, *,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Begin peer advertisement. This starts a task that will
            advertise the local peer every `every` seconds to the
            multicast group, and it will use the `app_id` as a URI to
            identify the application. The loop will drop any peers that
            have timed out. Raises AssertionError if `local_peer` is not
            set or if the message_type_class does not contain the
            'ADVERTISE_PEER' message type.
        """
        # preconditions
        assert self.local_peer is not None
        assert self.message_type_class.ADVERTISE_PEER is not None

        # start the advertisement loop task
        self._advertise_peer_tasks[app_id] = asyncio.create_task(
            self._advertise_peer_loop(
                every, app_id, peer_timeout,
                auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )
        )

    async def _advertise_peer_loop(
            self, every: int = 20, app_id: bytes = b'netaio',
            peer_timeout: int = 60, *,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Advertise peer loop."""
        # send a fresh message every time to avoid stale auth fields
        if self.peer_plugin is None or self.local_peer is None:
            self.logger.error(
                "peer_plugin or local_peer is None, cannot advertise"
            )
            return

        message = lambda: self.message_class.prepare(
            self.body_class.prepare(
                self.peer_plugin.pack(self.local_peer),
                app_id
            ),
            self.message_type_class.ADVERTISE_PEER,
        )
        disconnect_msg = self.message_class.prepare(
            self.body_class.prepare(
                self.peer_plugin.pack(self.local_peer),
                app_id
            ),
            self.message_type_class.DISCONNECT
        )
        while True:
            try:
                start_ts = time()
                # remove any timed out peers
                self.remove_timed_out_peers(peer_timeout)

                # advertise the peer
                self.logger.debug("Advertising peer")
                self.multicast(
                    message(), auth_plugin=auth_plugin,
                    cipher_plugin=cipher_plugin
                )
                done_ts = time()
                await asyncio.sleep(max(0.1, every - (done_ts - start_ts)))
            except asyncio.CancelledError:
                self.logger.debug("Advertise peer loop cancelled")
                self.multicast(
                    disconnect_msg, auth_plugin=auth_plugin,
                    cipher_plugin=cipher_plugin
                )
                break
            except Exception as e:
                self.logger.error("Error in advertise peer loop: %s", e)

    async def stop_peer_advertisement(self, app_id: bytes = b'netaio'):
        """Stop the peer advertisement task if it exists."""
        if app_id in self._advertise_peer_tasks:
            self._advertise_peer_tasks[app_id].cancel()
            del self._advertise_peer_tasks[app_id]

    async def manage_peers_automatically(
            self, advertise_every: int = 20, app_id: bytes = b'netaio',
            peer_timeout: int = 60, *,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Begins automatic peer management. This starts a task that
            will advertise the local peer every `advertise_every` seconds
            to the multicast group, and it will use the `app_id` as a URI
            to identify the application. Also registers 3 handlers: 1) for
            the 'ADVERTISE_PEER' message type which will add the peer to
            the peer list and respond with a 'PEER_DISCOVERED' message
            to reciprocate; 2) for the 'PEER_DISCOVERED' message that
            will add the peer to the peer list; and 3) for the
            'DISCONNECT' message which will remove the peer from the
            local peer list. The loop will also drop any peers that have
            timed out. Raises AssertionError if `local_peer` is not set
            or if the message_type_class does not contain
            'ADVERTISE_PEER', 'PEER_DISCOVERED', and 'DISCONNECT'
            message types.
        """
        # preconditions
        assert self.local_peer is not None
        assert self.message_type_class.ADVERTISE_PEER is not None
        assert self.message_type_class.PEER_DISCOVERED is not None
        assert self.message_type_class.DISCONNECT is not None

        # create the handlers
        @self.on(
            (self.message_type_class.ADVERTISE_PEER, app_id),
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )
        def handle_advertise_peer(message: MessageProtocol, addr: tuple[str, int]):
            self.logger.debug("Received ADVERTISE_PEER message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug(
                    "Ignoring ADVERTISE_PEER message with mismatched app_id"
                )
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content) if \
                    self.peer_plugin is not None else None
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            if peer is None:
                self.logger.error("peer_plugin is None or unpack returned None")
                return

            if peer.id is None or peer.data is None:
                self.logger.error("peer.id or peer.data is None")
                return

            if not self.add_or_update_peer(peer.id, peer.data, addr):
                return

            # prepare the response
            if self.peer_plugin is None or self.local_peer is None:
                self.logger.error("peer_plugin or local_peer is None")
                return

            return self.message_class.prepare(
                self.body_class.prepare(
                    self.peer_plugin.pack(self.local_peer),
                    app_id
                ),
                self.message_type_class.PEER_DISCOVERED
            )

        @self.on(
            (self.message_type_class.PEER_DISCOVERED, app_id),
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )
        def handle_peer_discovered(message: MessageProtocol, addr: tuple[str, int]):
            self.logger.debug("Received PEER_DISCOVERED message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug(
                    "Ignoring PEER_DISCOVERED message with mismatched app_id"
                )
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content) if \
                    self.peer_plugin is not None else None
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            if peer is None:
                self.logger.error("peer_plugin is None or unpack returned None")
                return

            if peer.id is None or peer.data is None:
                self.logger.error("peer.id or peer.data is None")
                return

            self.add_or_update_peer(peer.id, peer.data, addr)

        @self.on(
            (self.message_type_class.DISCONNECT, app_id),
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )
        def handle_disconnect(message: MessageProtocol, addr: tuple[str, int]):
            self.logger.debug("Received DISCONNECT message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring DISCONNECT message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content) if \
                    self.peer_plugin is not None else None
            except Exception as e:
                self.logger.error("Error unpacking peer id: %s", e)
                return

            if peer is None:
                self.logger.error("peer_plugin is None or unpack returned None")
                return

            if peer.id is None:
                self.logger.error("peer.id is None")
                return

            self.remove_peer(addr, peer.id)

        await self.begin_peer_advertisement(
            advertise_every, app_id, peer_timeout,
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )

    async def stop_peer_management(self, app_id: bytes = b'netaio'):
        """Stop automatic peer management by stopping peer advertisement
            and removing the handlers.
        """
        self.remove_handler((self.message_type_class.ADVERTISE_PEER, app_id))
        self.remove_handler((self.message_type_class.PEER_DISCOVERED, app_id))
        self.remove_handler((self.message_type_class.DISCONNECT, app_id))
        await self.stop_peer_advertisement()

    async def stop(self):
        """Stop the UDPNode."""
        for app_id in list(self._advertise_peer_tasks.keys()):
            await self.stop_peer_management(app_id)
        await self.cancel_timeout_handler_tasks()
        self.transport.close()

    def set_logger(self, logger: logging.Logger):
        """Replace the current logger."""
        self.logger = logger
