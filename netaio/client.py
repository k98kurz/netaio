from __future__ import annotations
from .common import (
    Header,
    AuthFields,
    Body,
    Message,
    MessageType,
    MessageTypeClassProtocol,
    HeaderProtocol,
    AuthFieldsProtocol,
    BodyProtocol,
    MessageProtocol,
    AuthPluginProtocol,
    CipherPluginProtocol,
    PeerPluginProtocol,
    Peer,
    keys_extractor,
    auth_error_handler,
    make_error_response,
    AnyHandler,
    AuthErrorHandler,
    TimeoutErrorHandler,
    DefaultPeerPlugin,
    default_client_logger,
    NetworkNodeProtocol,
    Handler,
)
from enum import IntEnum
from typing import Any, Awaitable, Callable, Coroutine, Hashable, cast
import asyncio
import logging


ClientHandler = Callable[
    [MessageProtocol, asyncio.StreamWriter],
    MessageProtocol | None | Coroutine[Any, Any, MessageProtocol | None]
]


class TCPClient:
    """TCP client class with multi-server connection support. A single
    TCPClient can connect to multiple servers simultaneously. Each server
    connection has its own receive loop that can be started and stopped
    independently. Use `connect()` to establish connections,
    `start_receive_loop()` to begin receiving from a server, and `close()`
    to disconnect.
    """
    hosts: dict[tuple[str, int], tuple[asyncio.StreamReader, asyncio.StreamWriter]]
    default_host: tuple[str, int]
    port: int
    local_peer: Peer | None
    peers: dict[bytes, Peer]
    peer_addrs: dict[tuple[str, int], bytes]
    header_class: type[HeaderProtocol]
    message_type_class: type[Any]
    auth_fields_class: type[AuthFieldsProtocol]
    body_class: type[BodyProtocol]
    message_class: type[MessageProtocol]
    handlers: dict[
        Hashable,
        tuple[AnyHandler, AuthPluginProtocol|None, CipherPluginProtocol|None]
    ]
    ephemeral_handlers: dict[
        Hashable,
        tuple[AnyHandler, AuthPluginProtocol|None, CipherPluginProtocol|None]
    ]
    default_handler: AnyHandler
    extract_keys: Callable[
        [MessageProtocol, tuple[str, int] | None],
        list[Hashable]
    ]
    make_error: Callable[[str], MessageProtocol]
    logger: logging.Logger
    auth_plugin: AuthPluginProtocol | None
    cipher_plugin: CipherPluginProtocol | None
    peer_plugin: PeerPluginProtocol | None
    handle_auth_error: AuthErrorHandler
    timeout_error_handler: TimeoutErrorHandler | None
    _receive_loop_tasks: dict[tuple[str, int], asyncio.Task]
    _receive_loop_lock: asyncio.Lock
    _timeout_handler_tasks: set[asyncio.Task]
    _timeout_handler_lock: asyncio.Lock
    _advertise_msg: MessageProtocol | None
    _disconnect_msg: MessageProtocol | None

    def __init__(
            self, host: str = "127.0.0.1", port: int = 8888, *,
            local_peer: Peer | None = None,
            header_class: type[HeaderProtocol] = Header,
            message_type_class: type[Any] = MessageType,
            auth_fields_class: type[AuthFieldsProtocol] = AuthFields,
            body_class: type[BodyProtocol] = Body,
            message_class: type[MessageProtocol] = Message,
            extract_keys: Callable[
                [MessageProtocol, tuple[str, int] | None],
                list[Hashable]
            ] = keys_extractor,
            logger: logging.Logger = default_client_logger,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None,
            peer_plugin: PeerPluginProtocol | None = None,
            auth_error_handler: AuthErrorHandler = auth_error_handler,
            timeout_error_handler: TimeoutErrorHandler | None = None,
        ):
        """Initialize the TCPClient.
            `host` is the default host IPv4 address to connect to.
            `port` is the default port to connect to.
            `local_peer` is the local peer information for this client.
            `header_class`, `auth_fields_class`, `body_class`, and
            `message_class` will be used for sending messages and
            parsing responses.
            `message_type_class` is the class to inject in calls to the
            decode method of the header class.
            `extract_keys` is a function that extracts the keys from a
            message.
            If `auth_plugin` is provided, it will be used to check the
            authenticity/authorization of all received messages and set
            the auth_fields of every sent message.
            If `cipher_plugin` is provided, it will be used to encrypt
            and decrypt all messages.
            If `peer_plugin` is provided, it will be used to encode and
            decode peer data.
            `auth_error_handler` is a function that handles auth errors,
            i.e. when an auth check fails for a received message. If it
            returns a message, that message will be sent as a response
            to the sender of the message that failed the auth check. The
            default handler returns the error message generated by the
            auth plugin and should be replaced if you do not want to
            send error messages for failed auth checks (e.g. if the
            auth plugin is an anti-spam plugin and messages that fail
            the auth check should just be dropped).
            `timeout_error_handler` is a function that handles timeout
            errors. It is called with (self, timeout_type, server, error,
            context) and can perform recovery actions like reconnecting
            or logging. The TimeoutError is always raised after the
            handler completes.
        """
        self.hosts = {}
        self.default_host = (host, port)
        self.port = port
        self.local_peer = local_peer
        self.peers = {}
        self.peer_addrs = {}
        self.header_class = header_class
        self.message_type_class = message_type_class
        self.auth_fields_class = auth_fields_class
        self.body_class = body_class
        self.message_class = message_class
        self.handlers = {}
        self.ephemeral_handlers = {}
        self.extract_keys = extract_keys
        self.logger = logger
        self.auth_plugin = auth_plugin
        self.cipher_plugin = cipher_plugin
        self.peer_plugin = peer_plugin or DefaultPeerPlugin()
        self.handle_auth_error = auth_error_handler
        self.handle_timeout_error = timeout_error_handler
        self._timeout_handler_tasks = set()
        self._timeout_handler_lock = asyncio.Lock()
        self._receive_loop_tasks = {}
        self._receive_loop_lock = asyncio.Lock()
        self._enable_automatic_peer_management = False
        self._disconnect_msg = None
        self._advertise_msg = None

    def add_handler(
            self, key: Hashable,
            handler: AnyHandler, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Register a handler for a specific key. The handler must
            accept a MessageProtocol object as an argument and return
            MessageProtocol, None, or a Coroutine that resolves to
            MessageProtocol | None. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the client. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the client.
        """
        self.logger.debug("Adding handler for key=%s", key)
        self.handlers[key] = (handler, auth_plugin, cipher_plugin)

    def add_ephemeral_handler(
            self, key: Hashable,
            handler: AnyHandler, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Register an ephemeral handler for a specific key. The handler
            will be removed either after it is called the first time.
            Otherwise identical to `add_handler`.
        """
        self.logger.debug("Adding ephemeral handler for key=%s", key)
        self.ephemeral_handlers[key] = (handler, auth_plugin, cipher_plugin)

    def on(
            self, key: Hashable, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Decorator to register a handler for a specific key. The
            handler must accept a MessageProtocol object as an argument
            and return a MessageProtocol, None, or a Coroutine that
            resolves to a MessageProtocol or None. If an auth plugin is
            provided, it will be used to check the message in addition
            to any auth plugin that is set on the client. If a cipher
            plugin is provided, it will be used to decrypt the message
            in addition to any cipher plugin that is set on the
            client.
        """
        def decorator(func: AnyHandler):
            self.add_handler(
                key, func, auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )
            return func
        return decorator

    def once(
            self, key: Hashable, *,
            auth_plugin: AuthPluginProtocol | None = None,
            cipher_plugin: CipherPluginProtocol | None = None
        ):
        """Decorator to register a one-time handler for a specific key.
            The handler must accept a MessageProtocol object as an
            argument and return a MessageProtocol, None, or a Coroutine
            that resolves to a MessageProtocol or None. If an auth
            plugin is provided, it will be used to check the message in
            addition to any auth plugin that is set on the client. If a
            cipher plugin is provided, it will be used to decrypt the
            message in addition to any cipher plugin that is set on the
            client.
        """
        def decorator(func: AnyHandler):
            self.add_ephemeral_handler(
                key, func, auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )
            return func
        return decorator

    def remove_handler(self, key: Hashable):
        """Remove a handler for a specific key."""
        self.logger.debug("Removing handler for key=%s", key)
        if key in self.handlers:
            del self.handlers[key]

    def remove_ephemeral_handler(self, key: Hashable):
        """Remove an ephemeral handler for a specific key."""
        self.logger.debug("Removing ephemeral handler for key=%s", key)
        if key in self.ephemeral_handlers:
            del self.ephemeral_handlers[key]

    async def connect(self, host: str | None = None, port: int | None = None):
        """Connect to a server.

            Establishes a TCP connection to specified host and port. The
            connection is stored in the hosts dict. To receive messages from
            this server, start a receive loop via `start_receive_loop()`.
            Multiple servers can be connected to simultaneously.
        """
        host = host or self.default_host[0]
        port = port or self.default_host[1]
        self.logger.info("Connecting to %s:%d", host, port)
        reader, writer = await asyncio.open_connection(host, port)
        self.hosts[(host, port)] = (reader, writer)
        if self._enable_automatic_peer_management and self._advertise_msg:
            await self.send(self._advertise_msg.copy(), server=(host, port))

    async def send(
            self, message: MessageProtocol, *,
            server: tuple[str, int] | None = None,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send a message to the server. If use_auth is True and an auth
            plugin is set, it will be called to set the auth fields on
            the message. If an auth plugin is provided, it will be used
            to authorize the message in addition to any auth plugin that
            is set on the client. If a cipher plugin is provided, it
            will be used to encrypt the message in addition to any
            cipher plugin that is set on the client. If use_auth is
            False, the auth plugin set on the client will not be used.
            If use_cipher is False, the cipher plugin set on the
            client will not be used.
        """
        server = server or self.default_host
        peer_id = self.peer_addrs.get(server)
        peer = self.peers.get(peer_id) if peer_id is not None else None

        # inner cipher
        if cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.encrypt on message")
            try:
                message = cipher_plugin.encrypt(
                    message, cast(NetworkNodeProtocol, self), peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.error("Error encrypting message", exc_info=True)
                return

        # inner auth
        if auth_plugin is not None:
            self.logger.debug("Calling auth_plugin.make on auth_data and body")
            auth_plugin.make(
                message.auth_data, message.body, cast(NetworkNodeProtocol, self),
                peer, self.peer_plugin
            )

        # outer cipher
        if use_cipher and self.cipher_plugin is not None:
            self.logger.debug("Calling self.cipher_plugin.encrypt on message")
            try:
                message = self.cipher_plugin.encrypt(
                    message, cast(NetworkNodeProtocol, self), peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.error("Error encrypting message", exc_info=True)
                return

        # outer auth
        if use_auth and self.auth_plugin is not None:
            self.logger.debug("Calling self.auth_plugin.make on auth_data and body")
            self.auth_plugin.make(
                message.auth_data, message.body, cast(NetworkNodeProtocol, self),
                peer, self.peer_plugin
            )

        self.logger.debug(
            "Sending message of type=%s to server...", message.header.message_type
        )
        _, writer = self.hosts[server]
        writer.write(message.encode())
        await writer.drain()
        self.logger.debug("Message sent to server")

    async def request(
            self, uri: bytes, *,
            server: tuple[str, int] | None = None,
            timeout: float = 10.0,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None,
            message_type: MessageType|None = None,
            content: bytes = b'',
        ) -> MessageProtocol:
        """Send a request message and wait for a response.
            Sets ephemeral handlers for OK, RESPOND_URI, AUTH_ERROR, ERROR, and
            NOT_FOUND message types, then sends a message to the connected server.
            Waits until a response (success or error) is received or timeout is
            reached. If it times out, removes all ephemeral handlers and raises
            a TimeoutError. If a response is received, returns that message
            (caller should check message.header.message_type to determine success
            or error).

            When message_type is None (default), sends REQUEST_URI. Use message_type
            and content to send CREATE_URI, UPDATE_URI, or DELETE_URI messages.
        """
        result = []
        event = asyncio.Event()
        server_addr = server or self.default_host
        message_type = message_type or self.message_type_class.REQUEST_URI

        keys = [
            (self.message_type_class.AUTH_ERROR, uri, server_addr),
            (self.message_type_class.ERROR, uri, server_addr),
        ]

        if message_type == self.message_type_class.REQUEST_URI:
            keys.append((self.message_type_class.RESPOND_URI, uri, server_addr))
        else:
            keys.append((self.message_type_class.OK, uri, server_addr))

        if message_type != self.message_type_class.CREATE_URI:
            keys.append((self.message_type_class.NOT_FOUND, uri, server_addr))

        def make_handler(my_key):
            def handle_any_response(
                message: MessageProtocol,
                writer: asyncio.StreamWriter
            ):
                result.append(message)
                event.set()
                for other_key in keys:
                    if other_key != my_key:
                        self.remove_ephemeral_handler(other_key)
            return handle_any_response

        for key in keys:
            handler = make_handler(key)
            self.add_ephemeral_handler(
                key, cast(ClientHandler, handler),
                auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
            )

        request_body = self.body_class.prepare(content=content, uri=uri)
        request_message = self.message_class.prepare(
            request_body, message_type
        )
        await self.send(
            request_message,
            server=server,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin
        )
        was_running = True

        try:
            task, was_running = await self.start_receive_loop(
                server=server,
                use_auth=use_auth,
                use_cipher=use_cipher,
                auth_plugin=auth_plugin,
                cipher_plugin=cipher_plugin,
            )
            deadline = asyncio.get_event_loop().time() + timeout
            try:
                await asyncio.wait_for(event.wait(), timeout=timeout)
            except asyncio.TimeoutError:
                if not len(result):
                    for key in keys:
                        self.remove_ephemeral_handler(key)
                    error = TimeoutError(
                        f"Request for URI {uri.decode('utf-8', errors='replace')} " +
                        f"timed out after {timeout}s"
                    )
                    context = {
                        'uri': uri,
                        'timeout': timeout,
                        'server': server_addr,
                        'keys': keys
                    }
                    await self._invoke_timeout_handler(
                        'request_timeout',
                        server_addr,
                        error,
                        context
                    )
                    raise error
        finally:
            if not was_running:
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass

        return result[0]

    async def create(
            self, uri: bytes, data: bytes, *,
            server: tuple[str, int] | None = None,
            timeout: float = 10.0,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol:
        """Send a CREATE_URI message and wait for an OK response.
            Sets ephemeral handlers for OK, AUTH_ERROR, ERROR, and
            NOT_FOUND message types using `add_ephemeral_handler`, then
            sends a CREATE_URI message to the connected server. Waits until
            either a response (success or error) is received or timeout is
            reached. If it times out, removes all ephemeral handlers and
            raises a TimeoutError. If a response is received, returns that
            message (caller should check message.header.message_type to
            determine if it's a success or error response).
        """
        return await self.request(
            uri=uri,
            server=server,
            timeout=timeout,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin,
            message_type=self.message_type_class.CREATE_URI,
            content=data
        )

    async def update(
            self, uri: bytes, data: bytes, *,
            timeout: float = 10.0,
            server: tuple[str, int] | None = None,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol:
        """Send an UPDATE_URI message and wait for an OK response.
            Sets ephemeral handlers for OK, AUTH_ERROR, ERROR, and
            NOT_FOUND message types using `add_ephemeral_handler`, then
            sends an UPDATE_URI message to the connected server. Waits until
            either a response (success or error) is received or timeout is
            reached. If it times out, removes all ephemeral handlers and
            raises a TimeoutError. If a response is received, returns that
            message (caller should check message.header.message_type to
            determine if it's a success or error response).
        """
        return await self.request(
            uri=uri,
            timeout=timeout,
            server=server,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin,
            message_type=self.message_type_class.UPDATE_URI,
            content=data
        )

    async def delete(
            self, uri: bytes, *,
            timeout: float = 10.0,
            server: tuple[str, int] | None = None,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol:
        """Send a DELETE_URI message and wait for an OK response.
            Sets ephemeral handlers for OK, AUTH_ERROR, ERROR, and
            NOT_FOUND message types using `add_ephemeral_handler`, then
            sends a DELETE_URI message to the connected server. Waits until
            either a response (success or error) is received or timeout is
            reached. If it times out, removes all ephemeral handlers and
            raises a TimeoutError. If a response is received, returns that
            message (caller should check message.header.message_type to
            determine if it's a success or error response).
        """
        return await self.request(
            uri=uri,
            timeout=timeout,
            server=server,
            use_auth=use_auth,
            use_cipher=use_cipher,
            auth_plugin=auth_plugin,
            cipher_plugin=cipher_plugin,
            message_type=self.message_type_class.DELETE_URI
        )

    async def receive_once(
            self, server: tuple[str, int] | None = None, *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol|None:
        """Receive a message from the server. If a handler was
            registered for the message key, the handler will be called
            with the message as an argument, and the result will be
            returned if it is not None; otherwise, the received message
            will be returned. If the message checksum fails, the message
            will be discarded and None will be returned. If an auth
            plugin is set, it will be checked before the message handler
            is called, and if the check fails, the message will be
            discarded and None will be returned. If use_auth is False,
            the auth plugin set on the client will not be used. If
            use_cipher is False, the cipher plugin set on the
            client will not be used. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the client. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the client.
        """
        self.logger.debug("Receiving message from server...")
        server = server or self.default_host
        peer_id = self.peer_addrs.get(server)
        peer = self.peers.get(peer_id) if peer_id is not None else None
        reader, writer = self.hosts[server]
        data = await reader.readexactly(self.header_class.header_length())
        header: HeaderProtocol = self.header_class.decode(
            data,
            message_type_factory=self.message_type_class
        )
        self.logger.debug(
            "Received message of type=%s from server", header.message_type
        )

        auth_bytes = await reader.readexactly(header.auth_length)
        auth: AuthFieldsProtocol = self.auth_fields_class.decode(auth_bytes)

        body_bytes = await reader.readexactly(header.body_length)
        body: BodyProtocol = self.body_class.decode(body_bytes)

        msg: MessageProtocol = self.message_class(
            header=header,
            auth_data=auth,
            body=body
        )

        if not msg.check():
            self.logger.warning("Message checksum failed")
            return None

        # outer auth
        if use_auth and self.auth_plugin is not None:
            self.logger.debug("Calling self.auth_plugin.check on auth and body")
            check = self.auth_plugin.check(
                msg.auth_data, msg.body, cast(NetworkNodeProtocol, self),
                peer, self.peer_plugin
            )
            if not check:
                self.logger.warning("Message auth failed")
                return self.handle_auth_error(
                    cast(NetworkNodeProtocol, self), self.auth_plugin, msg
                )

        # outer cipher
        if use_cipher and self.cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.decrypt on message")
            try:
                msg = self.cipher_plugin.decrypt(
                    msg, cast(NetworkNodeProtocol, self), peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.error("Error decrypting message; dropping", exc_info=True)
                return None

        # inner auth
        if auth_plugin is not None:
            self.logger.debug("Calling auth_plugin.check on auth and body")
            check = auth_plugin.check(
                msg.auth_data, msg.body, cast(NetworkNodeProtocol, self),
                peer, self.peer_plugin
            )
            if not check:
                self.logger.warning("Message auth failed")
                return self.handle_auth_error(
                    cast(NetworkNodeProtocol, self), auth_plugin, msg
                )

        # inner cipher
        if cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.decrypt on message")
            try:
                msg = cipher_plugin.decrypt(
                    msg, cast(NetworkNodeProtocol, self), peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.error("Error decrypting message; dropping", exc_info=True)
                return None

        keys = self.extract_keys(msg, server)
        handler_result: (
            MessageProtocol | Coroutine[Any, Any, MessageProtocol | None] | None
        ) = None

        self.logger.debug("Message received from server")
        for key in keys:
            if key in self.handlers or key in self.ephemeral_handlers:
                if key in self.ephemeral_handlers:
                    (
                        handler, auth_plugin, cipher_plugin
                    ) = self.ephemeral_handlers.pop(key)
                else:
                    handler, auth_plugin, cipher_plugin = self.handlers[key]

                # inner auth
                if auth_plugin is not None:
                    self.logger.debug("Calling auth_plugin.check on auth and body")
                    check = auth_plugin.check(
                        msg.auth_data, msg.body, self, peer, self.peer_plugin
                    )
                    if not check:
                        self.logger.warning("Message auth failed")
                        return self.handle_auth_error(self, auth_plugin, msg)

                # inner cipher
                if cipher_plugin is not None:
                    self.logger.debug("Calling cipher_plugin.decrypt on message")
                    try:
                        msg = cipher_plugin.decrypt(msg, self, peer, self.peer_plugin)
                    except Exception as e:
                        self.logger.error(
                            "Error decrypting message; dropping", exc_info=True
                        )
                        return None

                self.logger.debug("Calling handler for key=%s", key)
                tcp_handler = cast(Handler, handler)
                handler_result = tcp_handler(msg, writer)
                if isinstance(handler_result, Coroutine):
                    handler_result = await handler_result
                break

        if handler_result is not None:
            assert not isinstance(handler_result, Coroutine)
            return handler_result

        return msg

    async def receive_loop(
            self, server: tuple[str, int] | None = None, *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Receive messages from the server indefinitely. Use with
            asyncio.create_task() to run concurrently, then use
            task.cancel() to stop. If use_auth is False, the auth plugin
            set on the client will not be used. If use_cipher is
            False, the cipher plugin set on the client will not be
            used. If an auth plugin is provided, it will be used to
            check the message in addition to any auth plugin that is set
            on the client. If a cipher plugin is provided, it will be
            used to decrypt the message in addition to any cipher
            plugin that is set on the client.

            Note: This method is typically called via start_receive_loop()
            for better lifecycle management.
        """
        actual_server = server or self.default_host
        try:
            while True:
                try:
                    await self.receive_once(
                        actual_server,
                        use_auth=use_auth,
                        use_cipher=use_cipher,
                        auth_plugin=auth_plugin,
                        cipher_plugin=cipher_plugin
                    )
                except asyncio.CancelledError:
                    self.logger.info("Receive loop cancelled")
                    break
                except Exception as e:
                    self.logger.error("Error in receive_loop", exc_info=True)
                    break
        finally:
            async with self._receive_loop_lock:
                self._receive_loop_tasks.pop(actual_server, None)

    async def start_receive_loop(
            self, server: tuple[str, int] | None = None, *,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> tuple[asyncio.Task, bool]:
        """Start a receive loop for a specific server.

            Starts a receive loop that will continue receiving messages from
            specified server indefinitely until stopped. If a receive loop
            is already running for this server, returns the existing task.

            Returns: asyncio.Task object for the receive loop, which can be
                cancelled via task.cancel() when no longer needed.
        """
        server = server or self.default_host
        was_running = False

        async with self._receive_loop_lock:
            if server in self._receive_loop_tasks:
                task = self._receive_loop_tasks[server]
                if not task.done():
                    was_running = True
                    self.logger.debug(
                        "Receive loop already running for server %s, returning "
                        "existing task",
                        server
                    )
                    return (task, was_running)
                self._receive_loop_tasks.pop(server, None)

            task = asyncio.create_task(
                self.receive_loop(
                    server,
                    use_auth=use_auth,
                    use_cipher=use_cipher,
                    auth_plugin=auth_plugin,
                    cipher_plugin=cipher_plugin,
                )
            )
            self._receive_loop_tasks[server] = task

        self.logger.info("Started receive loop for server %s", server)
        return (task, was_running)

    async def stop_receive_loop(
            self, server: tuple[str, int] | None = None
        ) -> bool:
        """Stop the receive loop for a specific server.

            Cancels and waits for the receive loop task to complete. Returns
            True if a receive loop was stopped, False if no receive loop was
            running for this server.
        """
        server = server or self.default_host

        async with self._receive_loop_lock:
            task = self._receive_loop_tasks.pop(server, None)

        if task is None:
            self.logger.debug("No receive loop running for server %s", server)
            return False

        self.logger.info("Stopping receive loop for server %s", server)
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            pass

        return True

    async def stop_all_receive_loops(self) -> int:
        """Stop all running receive loops.

            Cancels and waits for all receive loop tasks to complete.
            Returns number of receive loops that were stopped.
        """
        async with self._receive_loop_lock:
            tasks_to_cancel = list(self._receive_loop_tasks.values())
            count = len(tasks_to_cancel)
            self._receive_loop_tasks.clear()

        if not tasks_to_cancel:
            self.logger.debug("No receive loops running")
            return 0

        self.logger.info("Stopping %d receive loop(s)", count)

        for task in tasks_to_cancel:
            task.cancel()

        await asyncio.gather(*tasks_to_cancel, return_exceptions=True)

        self.logger.info("Stopped %d receive loop(s)", count)
        return count

    async def get_receive_loops(self) -> dict[tuple[str, int], asyncio.Task]:
        """Get a copy of all active receive loop tasks.

            Returns a dictionary mapping server addresses to their
            receive loop tasks. Useful for monitoring and debugging.
        """
        async with self._receive_loop_lock:
            return self._receive_loop_tasks.copy()

    async def close(self, server: tuple[str, int] | None = None):
        """Close the connection to the server.

            Cancels any running receive loop for the server and closes
            the connection. Pass a `server` argument to disconnect from
            a non-default server.
        """
        server = server or self.default_host
        self.logger.info("Closing connection to server...")

        async with self._receive_loop_lock:
            task = self._receive_loop_tasks.get(server, None)

        if task is not None:
            self.logger.debug("Cancelling receive loop for server %s", server)
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass

        _, writer = self.hosts[server]
        if self._enable_automatic_peer_management and self._disconnect_msg:
            self.logger.debug("Sending disconnect message")
            await self.send(self._disconnect_msg.copy(), server=server)
        self.logger.debug("Closing writer")
        writer.close()
        self.logger.info("Connection to server closed")

    def add_or_update_peer(
            self, peer_id: bytes, peer_data: bytes, addr: tuple[str, int]
        ) -> bool:
        """Add or update a peer in the peer list. If the peer is the
            local peer, it will not be added to the peer list. Returns
            True if a PEER_DISCOVERED message should be sent (False if
            it is the local peer).
        """
        if self.local_peer is not None and peer_id == self.local_peer.id:
            self.logger.debug("Ignoring local peer.")
            return False
        if peer_id in self.peers:
            self.logger.debug(
                "Updating peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id].update(peer_data)
            self.peers[peer_id].addrs.add(addr)
        else:
            self.logger.debug(
                "Adding peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id] = Peer({addr}, peer_id, peer_data)
        self.peer_addrs[addr] = peer_id
        return True

    def get_peer(
            self, addr: tuple[str, int]|None = None, peer_id: bytes|None = None
        ) -> Peer|None:
        """Get a peer from the peer list if addr or peer_id is provided
            and if it exists. Prefers peer_id if both are provided but
            will fall back to addr if the provided peer_id is not found.
        """
        peer = None
        if peer_id is not None:
            peer = self.peers.get(peer_id) if peer_id is not None else None
        if addr is not None and peer is None:
            peer_id = self.peer_addrs.get(addr, None)
            peer = self.peers.get(peer_id) if peer_id is not None else None
        return peer

    def remove_peer(self, addr: tuple[str, int], peer_id: bytes):
        """Remove a peer from the peer list."""
        self.logger.debug(
            "Removing peer 0x%s at %s from peer list", peer_id.hex(), addr
        )
        if peer_id in self.peers:
            del self.peers[peer_id]
        if addr in self.peer_addrs:
            del self.peer_addrs[addr]

    async def manage_peers_automatically(
            self, app_id: bytes = b'netaio', *,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Begins automatic peer management: when the client connects to
            a server, it will send its local_peer data. This also
            registers 3 handlers: 1) for the 'ADVERTISE_PEER' message,
            which will add the peer to the peer list and send a
            'PEER_DISCOVERED' message to reciprocate; 2) for the
            'PEER_DISCOVERED' message type which will add the peer to
            the peer list; and 3) for the 'DISCONNECT' message which
            will remove the peer from the local peer list. Then, it will
            send an 'ADVERTISE_PEER' message to each server it has
            already connected to. Raises AssertionError if `local_peer`
            is not set or if the message_type_class does not contain
            'ADVERTISE_PEER', 'PEER_DISCOVERED', and 'DISCONNECT'
            message types.
        """
        # preconditions
        assert self.local_peer is not None
        assert hasattr(self.message_type_class, 'ADVERTISE_PEER')
        assert hasattr(self.message_type_class, 'PEER_DISCOVERED')
        assert hasattr(self.message_type_class, 'DISCONNECT')

        # set enable flag
        self._enable_automatic_peer_management = True

        # check that peer_plugin and local_peer are not None
        if self.peer_plugin is None or self.local_peer is None:
            self.logger.error("peer_plugin or local_peer is None")
            raise ValueError("peer_plugin and local_peer must not be None")

        # create the advertise message
        self._advertise_msg = self.message_class.prepare(
            self.body_class.prepare(
                self.peer_plugin.pack(self.local_peer),
                app_id
            ),
            self.message_type_class.ADVERTISE_PEER
        )

        # create the disconnect message
        self._disconnect_msg = self.message_class.prepare(
            self.body_class.prepare(
                self.peer_plugin.pack(self.local_peer),
                app_id
            ),
            self.message_type_class.DISCONNECT
        )

        if cipher_plugin is not None:
            if self._advertise_msg is not None:
                self._advertise_msg = cipher_plugin.encrypt(
                    self._advertise_msg, cast(NetworkNodeProtocol, self),
                    None, self.peer_plugin
                )
            if self._disconnect_msg is not None:
                self._disconnect_msg = cipher_plugin.encrypt(
                    self._disconnect_msg, cast(NetworkNodeProtocol, self),
                    None, self.peer_plugin
                )

        if auth_plugin is not None:
            if self._advertise_msg is not None:
                auth_plugin.make(
                    self._advertise_msg.auth_data,
                    self._advertise_msg.body,
                    cast(NetworkNodeProtocol, self), None, self.peer_plugin
                )
            if self._disconnect_msg is not None:
                auth_plugin.make(
                    self._disconnect_msg.auth_data,
                    self._disconnect_msg.body,
                    cast(NetworkNodeProtocol, self), None, self.peer_plugin
                )

        # create the handlers
        @self.on(
            (self.message_type_class.ADVERTISE_PEER, app_id),
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )
        def handle_advertise_peer(
                message: MessageProtocol, writer: asyncio.StreamWriter
            ):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received ADVERTISE_PEER message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug(
                    "Ignoring ADVERTISE_PEER message with mismatched app_id"
                )
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content) if \
                    self.peer_plugin is not None else None
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            if peer is None:
                self.logger.error("peer_plugin is None or unpack returned None")
                return

            if peer.id is None or peer.data is None:
                self.logger.error("peer.id or peer.data is None")
                return

            if not self.add_or_update_peer(peer.id, peer.data, addr):
                return

            # prepare the response
            if self.peer_plugin is None or self.local_peer is None:
                self.logger.error("peer_plugin or local_peer is None")
                return

            return self.message_class.prepare(
                self.body_class.prepare(
                    self.peer_plugin.pack(self.local_peer),
                    app_id
                ),
                self.message_type_class.PEER_DISCOVERED
            )

        @self.on(
            (self.message_type_class.PEER_DISCOVERED, app_id),
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )
        def handle_peer_discovered(
                message: MessageProtocol, writer: asyncio.StreamWriter
            ):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received PEER_DISCOVERED message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug(
                    "Ignoring PEER_DISCOVERED message with mismatched app_id"
                )
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content) if \
                    self.peer_plugin is not None else None
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            if peer is None:
                self.logger.error("peer_plugin is None or unpack returned None")
                return

            if peer.id is None or peer.data is None:
                self.logger.error("peer.id or peer.data is None")
                return

            self.add_or_update_peer(peer.id, peer.data, addr)

        @self.on(
            (self.message_type_class.DISCONNECT, app_id),
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
        )
        def handle_disconnect(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received DISCONNECT message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring DISCONNECT message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content) if \
                    self.peer_plugin is not None else None
            except Exception as e:
                self.logger.error("Error unpacking peer id: %s", e)
                return

            if peer is None:
                self.logger.error("peer_plugin is None or unpack returned None")
                return

            if peer.id is None:
                self.logger.error("peer.id is None")
                return

            self.remove_peer(addr, peer.id)

        for addr in self.hosts:
            if self._advertise_msg is not None:
                await self.send(self._advertise_msg.copy(), server=addr)

    async def stop_peer_management(self, app_id: bytes = b'netaio'):
        """Stops automatic peer management by disabling the feature,
            sending a DISCONNECT message, and removing the handlers.
        """
        self._enable_automatic_peer_management = False
        self.remove_handler((self.message_type_class.ADVERTISE_PEER, app_id))
        self.remove_handler((self.message_type_class.PEER_DISCOVERED, app_id))
        self.remove_handler((self.message_type_class.DISCONNECT, app_id))
        if self._disconnect_msg:
            for addr in self.peer_addrs:
                await self.send(self._disconnect_msg.copy(), server=addr)

    def set_logger(self, logger: logging.Logger):
        """Replace the current logger."""
        self.logger = logger

    def set_timeout_handler(self, handler: TimeoutErrorHandler):
        """Set or replace the timeout error handler. Experimental
            and of unknown utility as of v0.0.9.
        """
        self.handle_timeout_error = handler

    async def _invoke_timeout_handler(
            self,
            timeout_type: str,
            server: tuple[str, int] | None,
            error: TimeoutError,
            context: dict[str, Any]
        ):
        """Invoke the timeout error handler with sync/async handling."""
        if self.handle_timeout_error is None:
            return

        result = self.handle_timeout_error(
            self, timeout_type, server, error, context
        )

        if isinstance(result, Coroutine):
            task = asyncio.create_task(result)
            self._timeout_handler_tasks.add(task)
            task.add_done_callback(self._timeout_handler_tasks.discard)

    async def cancel_timeout_handler_tasks(self):
        """Cancel all running timeout handler tasks."""
        async with self._timeout_handler_lock:
            for task in list(self._timeout_handler_tasks):
                task.cancel()
            await asyncio.gather(*self._timeout_handler_tasks, return_exceptions=True)
            self._timeout_handler_tasks.clear()


class AutoReconnectTimeoutHandler:
    """Bundled timeout handler that automatically reconnects to server.

    This handler runs as a side effect when a timeout occurs, attempting to
    re-establish the connection so subsequent requests can succeed. The original
    TimeoutError is always raised after the handler completes.

    Constructor Parameters:
        connect_timeout: Timeout in seconds for each connect attempt
        max_retries: Maximum number of reconnect attempts
        delay: Delay in seconds between retry attempts
        on_reconnect: Optional callback invoked on successful reconnect,
                      called with client, server, and attempt_number arguments

    Usage:
        handler = AutoReconnectTimeoutHandler(
            connect_timeout=5.0,
            max_retries=3,
            delay=1.0,
            on_reconnect=lambda client, server, attempt: ...
        )
        client.set_timeout_handler(handler)
    """

    def __init__(
        self,
        connect_timeout: float = 5.0,
        max_retries: int = 3,
        delay: float = 1.0,
        on_reconnect: Callable[
            [TCPClient, tuple[str, int], int],
            Awaitable[None] | None
        ] | None = None
    ):
        self._connect_timeout = connect_timeout
        self._max_retries = max_retries
        self._delay = delay
        self._on_reconnect = on_reconnect

    async def __call__(
        self,
        client: TCPClient,
        timeout_type: str,
        server: tuple[str, int] | None,
        error: TimeoutError,
        context: dict[str, Any]
    ) -> None:
        """Attempt to reconnect after a timeout.

        Args:
            client: The TCPClient instance that experienced the timeout
            timeout_type: Type of timeout that occurred
            server: The server address (host, port) or None for default
            error: The TimeoutError that was raised
            context: Additional context about the timeout

        Returns:
            None - the TimeoutError is always raised by request() after this
        """
        if timeout_type != 'request_timeout':
            return

        target_server = server or client.default_host
        client.logger.info(
            "Auto-reconnect handler invoked for server %s:%s (max_retries=%d)",
            target_server[0], target_server[1], self._max_retries
        )

        for attempt in range(1, self._max_retries + 1):
            try:
                client.logger.info(
                    "Reconnect attempt %d/%d to %s:%s",
                    attempt, self._max_retries, target_server[0], target_server[1]
                )
                await asyncio.wait_for(
                    client.connect(target_server[0], target_server[1]),
                    timeout=self._connect_timeout
                )
                client.logger.info(
                    "Successfully reconnected to %s:%s",
                    target_server[0], target_server[1]
                )

                if self._on_reconnect is not None:
                    result = self._on_reconnect(client, target_server, attempt)
                    if isinstance(result, Coroutine):
                        await result

                return

            except asyncio.TimeoutError:
                client.logger.warning(
                    "Reconnect attempt %d/%d to %s:%s timed out",
                    attempt, self._max_retries, target_server[0], target_server[1]
                )
            except ConnectionError as e:
                client.logger.warning(
                    "Reconnect attempt %d/%d to %s:%s failed: %s",
                    attempt, self._max_retries, target_server[0],
                    target_server[1], str(e)
                )
            except Exception as e:
                client.logger.error(
                    "Reconnect attempt %d/%d to %s:%s encountered unexpected error",
                    attempt, self._max_retries, target_server[0], target_server[1],
                    exc_info=True
                )

            if attempt < self._max_retries:
                await asyncio.sleep(self._delay)

        client.logger.error(
            "Failed to reconnect to %s:%s after %d attempts",
            target_server[0], target_server[1], self._max_retries
        )
