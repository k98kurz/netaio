# Progress

## Task 4: Add Timeout Handler Infrastructure to TCPClient

### In Progress
- Added `TimeoutErrorHandler` and `Any` to imports from common and typing
- Added `timeout_error_handler`, `_timeout_handler_tasks`, and `_timeout_handler_lock` class attributes
- Added `timeout_error_handler` parameter to `__init__` with default None
- Initialized `_timeout_error_handler`, `_timeout_handler_tasks`, and `_timeout_handler_lock` in `__init__`
- Implemented `set_timeout_handler(handler)` method
- Implemented async `_invoke_timeout_handler(timeout_type, server, error, context)` method
  - Handles both sync (blocking) and async (tracked task) handlers
  - For async handlers, creates task and adds to `_timeout_handler_tasks` set
  - Task automatically removed from set when completed via callback
- Implemented async `cancel_timeout_handler_tasks()` method
  - Uses lock to safely cancel and wait for all running timeout handler tasks
- Modified `request()` method to call `_invoke_timeout_handler()` before raising TimeoutError
  - Creates error instance, context dict with uri, timeout, server, key
  - Calls handler with 'request_timeout' type before raising

### Acceptance Criteria Status
✓ Import TimeoutErrorHandler from common module
✓ Add timeout_error_handler parameter to __init__ with default None
✓ Initialize _timeout_error_handler, _timeout_handler_tasks set, and _timeout_handler_lock
✓ Implement set_timeout_handler(handler) method
✓ Implement async _invoke_timeout_handler(timeout_type, server, error, context) method
✓ Implement async cancel_timeout_handler_tasks() method
✓ Call _invoke_timeout_handler() before raising TimeoutError in request() with descriptive timeout_type and relevant context dict
✓ Handlers executed with proper sync/async handling and task tracking
✓ TimeoutError is always raised after the handler completes

### Tests
28 tests pass (2 failures are pre-existing UDP test issues unrelated to TCPClient changes)

### Status
**IN PROGRESS** - All acceptance criteria met; needs testing of timeout handler behavior with actual handler implementations

---

## Task 1: Add TimeoutErrorHandler Type Definition

### Completed
- Added `Awaitable` to typing imports in netaio/common.py
- Added `TimeoutErrorHandler` type definition after `AuthErrorHandler` at line 724-727 in netaio/common.py
- Type signature: `Callable[[NetworkNodeProtocol, str, tuple[str, int] | None, TimeoutError, dict[str, Any]], Awaitable[None] | None]`

### Acceptance Criteria Met
✓ TimeoutErrorHandler type defined with correct signature accepting NetworkNodeProtocol, timeout_type, server, error, and context
✓ Type accepts both sync (None) and async (Awaitable[None]) return types
✓ Located after AuthErrorHandler definition in common.py

### Status
**COMPLETE** - Task 1 can be marked as "In Review"

---

## Task 3: Fix Race Condition in TCPClient.receive_loop()

### Completed
- Added `_receive_loop_task: asyncio.Task | None` class attribute to TCPClient
- Initialized `_receive_loop_task = None` in `__init__` method
- Modified `receive_loop()` to set `self._receive_loop_task = asyncio.current_task()` at start and `= None` in finally block
- Modified `request()` to use `was_running` variable to track if receive_loop was already running
- Modified `request()` to check if receive_loop is already running: `was_running = (self._receive_loop_task is not None and not self._receive_loop_task.done())`
- Modified `request()` to only create new task if not already running
- Modified `request()` to only cancel task in finally block if it was created during the call (i.e., not was_running)

### Acceptance Criteria Met
✓ _receive_loop_task: asyncio.Task | None instance variable added to TCPClient class
✓ receive_loop() sets self._receive_loop_task = asyncio.current_task() at start
✓ receive_loop() sets self._receive_loop_task = None in finally block
✓ request() uses local variable `was_running` to track if receive_loop was already running
✓ request() checks if receive_loop is already running: `was_running = (self._receive_loop_task is not None and not self._receive_loop_task.done())`
✓ request() only creates new task if not already running
✓ request() only cancels task in finally block if it was created during the call (i.e., not was_running)

### Status
**IN REVIEW** - All acceptance criteria met; 28 tests pass including 8 TCP e2e tests
