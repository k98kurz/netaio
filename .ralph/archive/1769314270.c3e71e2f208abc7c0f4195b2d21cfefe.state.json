{
  "iteration": 1,
  "current_phase": "COMMIT",
  "failed_phase": null,
  "retry_count": 0,
  "max_iterations": 20,
  "enhanced_mode": true,
  "test_instructions": "You should test your work with mocks",
  "review_every": 0,
  "model": "zai-coding-plan/glm-4.7",
  "review_model": "zai-coding-plan/glm-4.7",
  "lock_token": "c3e71e2f208abc7c0f4195b2d21cfefe",
  "start_time": 1769313692.1601264,
  "phase_history": [
    "BUILD_1",
    "REVIEW_1",
    "COMMIT_1"
  ],
  "last_error": null,
  "final_review_requested": false,
  "is_complete": false,
  "mock_mode": false,
  "push_commits": false,
  "original_prompt": "Implement two fixes for the netaio library:\n\n## Fix 1: Race Condition in TCPClient.request()\n\nAdd task tracking to prevent concurrent `receive_loop` tasks from corrupting the TCP stream:\n\n1. Add `_receive_loop_task: asyncio.Task | None` instance variable to TCPClient\n2. In `receive_loop()`, set `self._receive_loop_task = asyncio.current_task()` at start and `= None` in finally block\n3. In `request()`, check if receive_loop is already running before creating new task:\n   - `was_running = (self._receive_loop_task is not None and not self._receive_loop_task.done())`\n   - Only create new task if not already running\n   - Cancel task in finally block only if we created it\n\n## Fix 2: Timeout Error Handler Feature\n\nAdd centralized timeout recovery to both TCPClient and UDPNode:\n\n### Type Definition (netaio/common.py):\nAdd `TimeoutErrorHandler` type after `AuthErrorHandler`:\n```python\nTimeoutErrorHandler = Callable[\n    [NetworkNodeProtocol, str, tuple[str, int] | None, TimeoutError, dict[str, Any]],\n    Awaitable[None] | None\n]\n```\n\n### TCPClient Changes (netaio/client.py):\n1. Import `TimeoutErrorHandler` from common\n2. Add `timeout_error_handler: TimeoutErrorHandler = None` parameter to `__init__`\n3. Initialize: `self._timeout_error_handler`, `self._timeout_handler_tasks: set[asyncio.Task]`, `self._timeout_handler_lock: asyncio.Lock`\n4. Add `set_timeout_handler(handler)` method\n5. Add `async _invoke_timeout_handler(timeout_type, server, error, context)` method\n6. Add `async cancel_timeout_handler_tasks()` method\n7. In `request()`, call `await self._invoke_timeout_handler(...)` before raising TimeoutError\n\n### UDPNode Changes (netaio/node.py):\nSame as TCPClient (steps 1-7) but without AutoReconnectTimeoutHandler\n\n### AutoReconnectTimeoutHandler (netaio/client.py):\nAdd at bottom of file - bundled handler that auto-reconnects on timeout:\n- Constructor params: `connect_timeout`, `max_retries`, `delay`, `on_reconnect` callback\n- `async __call__` method implements reconnect logic with retry loop\n\n### Exports (netaio/__init__.py):\nExport `TimeoutErrorHandler` and `AutoReconnectTimeoutHandler`\n\n## Type Hint Fixes:\n\n`keys_extractor` type hints should accept `tuple[str, int] | None` as second parameter:\n- `netaio/common.py` line 239: Protocol definition\n- `netaio/client.py` line 43 (class attribute), line 58 (`__init__` param)\n- `netaio/node.py` line 53 (class attribute), line 75 (`__init__` param)\n\n## Code Style:\n\n- Try to keep lines around 80-85 characters maximum\n- Use multi-line for long statements\n- Follow existing conventions\n\n## Key Design Decisions:\n\n1. Sync handlers execute synchronously (blocking before re-raise)\n2. Async handlers run as tracked tasks, cleanup via `cancel_timeout_handler_tasks()`\n3. No AutoReconnectTimeoutHandler for UDP (connectionless)\n4. Timeout handler only for `request()` method\n5. AutoReconnectTimeoutHandler lives at bottom of client.py (not separate file)",
  "phase_recovered": false,
  "timeout": 1200
}