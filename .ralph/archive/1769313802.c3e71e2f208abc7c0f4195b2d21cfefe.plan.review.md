# Plan Review

## Overall Assessment
The plan is well-structured and follows the required format with Status, Description, and Acceptance Criteria for each task. The task breakdown is logical and the dependencies are correctly identified.

## Critical Issues

### 1. Task 2 Type Hints Analysis is Incomplete

**Issue:** The acceptance criteria mentions updating `netaio/common.py` line 239, but this is incomplete.

**Analysis:**
- Line 239 in common.py defines the `extract_keys` property in `NetworkNodeProtocol` as:
  `Callable[[MessageProtocol], list[Hashable]]`
- The actual `keys_extractor` function (line 753-767) already accepts `tuple[str, int] | None`:
  `keys_extractor(message: MessageProtocol, host: tuple[str, int]|None = None)`
- The protocol definition needs updating to match the function signature

**Recommendation:** Update Task 2 acceptance criteria to clarify that the `NetworkNodeProtocol.extract_keys` property at common.py line 239 needs its type signature changed from `Callable[[MessageProtocol], list[Hashable]]` to `Callable[[MessageProtocol, tuple[str, int] | None], list[Hashable]]`.

### 2. Task 4 and Task 6 Missing Critical Implementation Details

**Issue:** The acceptance criteria for calling `_invoke_timeout_handler()` don't specify what values to pass for `timeout_type` and `context`.

**Analysis:**
- Acceptance criterion says "Call _invoke_timeout_handler() before raising TimeoutError in request()"
- But doesn't specify:
  - What `timeout_type` string to pass (e.g., "request_timeout")
  - What dictionary keys/values to include in `context`
- This ambiguity could lead to inconsistent implementations between TCPClient and UDPNode

**Recommendation:** Add specific acceptance criteria for `_invoke_timeout_handler()`:
- "Pass timeout_type='request_timeout' (or a descriptive string)"
- "Include context dict with: uri, timeout, server, timestamp"

### 3. Task 5 Lacks Implementation Specification

**Issue:** The acceptance criteria are too vague about the retry logic.

**Analysis:**
- Criteria states "implements async reconnect logic with retry loop"
- Doesn't specify:
  - How to calculate the next timeout (should it be cumulative?)
  - What happens after successful reconnect (return None or raise original error?)
  - How to handle the original TimeoutError after retries exhausted
  - What logging messages to emit

**Recommendation:** Expand acceptance criteria to specify:
- "Retry loop increments attempts up to max_retries"
- "On each retry, call client.connect() with connect_timeout"
- "If reconnect succeeds, return None (allow request to retry)"
- "After max_retries exhausted, raise the original TimeoutError"
- "Log warning for each retry attempt and error for final failure"

## Minor Issues

### 4. Missing netaio/__init__.py Analysis
The plan doesn't show the current state of netaio/__init__.py to verify what exports need to be added.

### 5. UDPNode receive_loop() Reference
The plan mentions "receive_loop()" but UDPNode doesn't have this method - it uses `datagram_received()` callback. Task 6's acceptance criteria correctly refers only to `request()`, so this is just a naming inconsistency in the description.

## Summary
The plan is solid overall. The top 3 issues above should be addressed before implementation to ensure consistency and completeness. Tasks 1, 3, 5, and 7 are well-specified. Tasks 2, 4, and 6 need clarification on the details noted above.
