# Implementation Plan

## Tasks

### TASK 1: Add TimeoutErrorHandler Type Definition

- Status: Done
- Description: Add TimeoutErrorHandler type alias to netaio/common.py after AuthErrorHandler definition
- Acceptance Criteria:
    - TimeoutErrorHandler type defined with correct signature accepting NetworkNodeProtocol, timeout_type, server, error, and context
    - Type accepts both sync (None) and async (Awaitable[None]) return types
    - Located after AuthErrorHandler definition in common.py

### TASK 2: Fix Type Hints for keys_extractor

- Status: Pending
- Description: Update keys_extractor type hints to accept tuple[str, int] | None as second parameter
- Acceptance Criteria:
    - NetworkNodeProtocol.extract_keys property in common.py (line ~239, search by context) type changed from `Callable[[MessageProtocol], list[Hashable]]` to `Callable[[MessageProtocol, tuple[str, int] | None], list[Hashable]]`
    - TCPClient class attribute in netaio/client.py updated (line ~43, search by context)
    - TCPClient __init__ parameter in netaio/client.py updated (line ~58, search by context)
    - UDPNode class attribute in netaio/node.py updated (line ~53, search by context)
    - UDPNode __init__ parameter in netaio/node.py updated (line ~75, search by context)

### TASK 3: Fix Race Condition in TCPClient.receive_loop()

- Status: In Review
- Description: Add task tracking to prevent concurrent receive_loop tasks from corrupting TCP stream
- Acceptance Criteria:
    - _receive_loop_task: asyncio.Task | None instance variable added to TCPClient class
    - receive_loop() sets self._receive_loop_task = asyncio.current_task() at start
    - receive_loop() sets self._receive_loop_task = None in finally block
    - request() uses local variable `was_running` to track if receive_loop was already running
    - request() checks if receive_loop is already running: `was_running = (self._receive_loop_task is not None and not self._receive_loop_task.done())`
    - request() only creates new task if not already running
    - request() only cancels task in finally block if it was created during the call (i.e., not was_running)

### TASK 4: Add Timeout Handler Infrastructure to TCPClient

- Status: Pending
- Description: Implement timeout error handler support in TCPClient class
- Acceptance Criteria:
    - Import TimeoutErrorHandler from common module
    - Add timeout_error_handler parameter to __init__ with default None
    - Initialize _timeout_error_handler, _timeout_handler_tasks set, and _timeout_handler_lock
    - Implement set_timeout_handler(handler) method
    - Implement async _invoke_timeout_handler(timeout_type, server, error, context) method
    - Implement async cancel_timeout_handler_tasks() method
    - Call _invoke_timeout_handler() before raising TimeoutError in request() with descriptive timeout_type and relevant context dict
    - Handlers executed with proper sync/async handling and task tracking
    - **Important**: TimeoutError is always raised after the handler completes; handlers run for side effects only (e.g., logging, reconnecting connection for future use)

### TASK 5: Implement AutoReconnectTimeoutHandler for TCPClient

- Status: Pending
- Description: Create bundled auto-reconnect timeout handler at bottom of client.py
- Acceptance Criteria:
    - Class defined at bottom of netaio/client.py
    - Constructor accepts connect_timeout, max_retries, delay, on_reconnect parameters
    - __call__ method implements async reconnect logic with retry loop
    - Attempts to reconnect and invokes on_reconnect callback on success
    - Returns None (the TimeoutError is always raised by request() after handler completes)
    - Handler runs for side effects: prepares connection for subsequent requests after the current one fails
    - Proper error handling and logging throughout

### TASK 6: Add Timeout Handler Infrastructure to UDPNode

- Status: Pending
- Description: Implement timeout error handler support in UDPNode class (same as TCPClient)
- Acceptance Criteria:
    - Import TimeoutErrorHandler from common module
    - Add timeout_error_handler parameter to __init__ with default None
    - Initialize _timeout_error_handler, _timeout_handler_tasks set, and _timeout_handler_lock
    - Implement set_timeout_handler(handler) method
    - Implement async _invoke_timeout_handler(timeout_type, server, error, context) method
    - Implement async cancel_timeout_handler_tasks() method
    - Call _invoke_timeout_handler() before raising TimeoutError in request() with descriptive timeout_type and relevant context dict
    - Handlers executed with proper sync/async handling and task tracking
    - **Important**: TimeoutError is always raised after the handler completes; handlers run for side effects only
    - No AutoReconnectTimeoutHandler added (UDP is connectionless)

### TASK 7: Update Module Exports

- Status: Pending
- Description: Export new types and handlers from netaio/__init__.py
- Acceptance Criteria:
    - TimeoutErrorHandler exported from netaio.__init__
    - AutoReconnectTimeoutHandler exported from netaio.__init__
    - Exports accessible via `from netaio import TimeoutErrorHandler, AutoReconnectTimeoutHandler`

## Dependencies

- **Task 1** (TimeoutErrorHandler type) must be completed before Task 4 and Task 6 (TCPClient/UDPNode implementation)
- **Task 2** (Type hints) can be completed independently at any time
- **Task 3** (Race condition fix) can be completed independently of timeout handler work
- **Task 4** (TCPClient timeout infrastructure) must be completed before Task 5 (AutoReconnectTimeoutHandler)
- **Task 4** and **Task 6** (UDPNode timeout infrastructure) can be completed in parallel after Task 1
- **Task 5** (AutoReconnectTimeoutHandler) and **Task 6** can be completed in parallel after Task 4
- **Task 7** (Exports) must be completed after Task 5 (AutoReconnectTimeoutHandler implementation)
